/* Generated By:CSharpCC: Do not edit this line. GRSImporter.cs */
    namespace de.unika.ipd.grGen.libGr.porter {

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using de.unika.ipd.grGen.libGr;

        struct Param
        {
        public String Key; // the attribute name

        // for basic types, enums
        public String Value; // the attribute value

        // for set, map attributed
        public String Type; // set/map(domain) type
        public String TgtType; // map target type
        public ArrayList Values; // set/map(domain) values 
        public ArrayList TgtValues; // map target values

        public Param(String key, String value)
        {
            Key = key;
            Value = value;
            Type = null;
            TgtType = null;
            Values = null;
            TgtValues = null;
        }

        public Param(String key, String value, String type)
        {
            Key = key;
            Value = value;
            Type = type;
            TgtType = null;
            Values = new ArrayList();
            TgtValues = null;
        }

        public Param(String key, String value, String type, String tgtType)
        {
            Key = key;
            Value = value;
            Type = type;
            TgtType = tgtType;
            Values = new ArrayList();
            TgtValues = new ArrayList();
        }
    }

        class ElementDef
    {
        public String ElemName;
        public String TypeName;
        public ArrayList Attributes;

        public ElementDef(String elemName, String typeName, ArrayList attributes)
        {
            ElemName = elemName;
            TypeName = typeName;
            Attributes = attributes;
        }
    }

    class GRSImporter : GRSImporterConstants {
                INamedGraph graph;
                IBackend backend;
                IGraphModel model;
                String modelOverride;
                BaseActions actions;

        /// <summary>
        /// Imports the given graph from a file with the given filename.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="importFilename">The filename of the file to be imported.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="modelOverride">The graph model to be used, 
        ///     it must be conformant to the model used in the file to be imported.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(String importFilename, String modelOverride, IBackend backend, out BaseActions actions)
        {
            return Import(new StreamReader(importFilename), modelOverride, backend, out actions);
        }

        /// <summary>
        /// Imports the given graph from the given text reader input stream.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="reader">The text reader input stream import source.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="modelOverride">The graph model to be used, 
        ///     it must be conformant to the model used in the file to be imported.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(TextReader reader, String modelOverride, IBackend backend, out BaseActions actions)
        {
            GRSImporter importer = new GRSImporter(reader);
            importer.backend = backend;
            importer.modelOverride = modelOverride;
            importer.model = null;
            while(importer.ParseGraphBuildingScript()) /*empty*/;
                        actions = importer.actions;
            return importer.graph;
        }

        /// <summary>
        /// Imports the given graph from a file with the given filename.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="importFilename">The filename of the file to be imported.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(String importFilename, IBackend backend, out BaseActions actions)
        {
            return Import(importFilename, null, backend, out actions);
        }

                /// <summary>
        /// Imports the given graph from a file with the given filename.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="importFilename">The filename of the file to be imported.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="graphModel">The graph model to be used.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(String importFilename, IBackend backend, IGraphModel graphModel, out BaseActions actions)
                {
            return Import(new StreamReader(importFilename), backend, graphModel, out actions);
        }

        /// <summary>
        /// Imports the given graph from the given text reader input stream.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="reader">The text reader input stream import source.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="graphModel">The graph model to be used.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(TextReader reader, IBackend backend, IGraphModel graphModel, out BaseActions actions)
        {
            GRSImporter importer = new GRSImporter(reader);
            importer.backend = backend;
            importer.modelOverride = null;
            importer.model = graphModel;
            while(importer.ParseGraphBuildingScript()) /*empty*/;
                        actions = importer.actions;
            return importer.graph;
        }

        public INode GetNodeByName(String elemName)
        {
            return (INode)GetElemByName(elemName);
        }

        public IEdge GetEdgeByName(String elemName)
        {
            return (IEdge)GetElemByName(elemName);
        }

        public IGraphElement GetElemByName(String elemName)
        {
                IGraphElement elem = graph.GetGraphElement(elemName);
                if(elem==null) throw new Exception("Unknown graph element "+elemName);
            return elem;
        }

        public void NewNode(ElementDef elemDef)
        {
            NodeType nodeType;
            if(elemDef.TypeName != null)
            {
                nodeType = graph.Model.NodeModel.GetType(elemDef.TypeName);
                if(nodeType==null) throw new Exception("Unknown node type: \"" + elemDef.TypeName + "\"");
                if(nodeType.IsAbstract) throw new Exception("Abstract node type \"" + elemDef.TypeName + "\" may not be instantiated!");
            }
            else nodeType = graph.Model.NodeModel.RootType;

                        INode node = graph.AddNode(nodeType, elemDef.ElemName);
                        if(node==null) throw new Exception("Can't create node");

            if(elemDef.Attributes!=null) SetAttributes(node, elemDef.Attributes);
        }

        public void NewEdge(ElementDef elemDef, INode node1, INode node2)
        {
            EdgeType edgeType;
            if(elemDef.TypeName != null)
            {
                edgeType = graph.Model.EdgeModel.GetType(elemDef.TypeName);
                if(edgeType==null) throw new Exception("Unknown edge type: \"" + elemDef.TypeName + "\"");
                if(edgeType.IsAbstract) throw new Exception("Abstract edge type \"" + elemDef.TypeName + "\" may not be instantiated!");
            }
            else edgeType = graph.Model.EdgeModel.RootType;

            IEdge edge = graph.AddEdge(edgeType, node1, node2, elemDef.ElemName);
            if(edge==null) throw new Exception("Can't create edge");

            if(elemDef.Attributes!=null) SetAttributes(edge, elemDef.Attributes);
        }

        public void DeferredAttributeInitialization(IGraphElement elem, ArrayList defrAttrInit)
        {
                SetAttributes(elem, defrAttrInit);
        }

                public void DeferredAttributeInitialization(IGraphElement elem, string attr, string idx, string val)
        {
                        AttributeType attrType = elem.Type.GetAttributeType(attr);
                        if(attrType.Kind == AttributeKind.ArrayAttr)
                        {
                                IList array = (IList)elem.GetAttribute(attr);
                                object index = ParseAttributeValue(AttributeKind.IntegerAttr, idx);
                                object value = ParseAttributeValue(attrType.ValueType, val);
                                AttributeChangeType changeType = AttributeChangeType.AssignElement;
                                if (elem is INode)
                                        graph.ChangingNodeAttribute((INode)elem, attrType, changeType, value, index);
                                else
                                        graph.ChangingEdgeAttribute((IEdge)elem, attrType, changeType, value, index);
                                array[(int)index] = value;
                        }
                        else
                        {
                                IDictionary setmap = (IDictionary)elem.GetAttribute(attr);
                                object index = ParseAttributeValue(attrType.KeyType, idx);
                                object value = ParseAttributeValue(attrType.ValueType, val);
                                AttributeChangeType changeType = AttributeChangeType.AssignElement;
                                if (elem is INode)
                                        graph.ChangingNodeAttribute((INode)elem, attrType, changeType, value, index);
                                else
                                        graph.ChangingEdgeAttribute((IEdge)elem, attrType, changeType, value, index);
                                setmap[index] = value;
                        }
        }

                private object ParseAttributeValue(AttributeKind attrKind, String valueString) // not set/map/array/enum
        {
            object value = null;
            switch(attrKind)
            {
            case AttributeKind.BooleanAttr:
                if(valueString.Equals("true", StringComparison.OrdinalIgnoreCase))
                    value = true;
                else if(valueString.Equals("false", StringComparison.OrdinalIgnoreCase))
                    value = false;
                else
                    throw new Exception("Unknown boolean literal");
                break;
            case AttributeKind.ByteAttr:
                if(valueString.StartsWith("0x"))
                    value = SByte.Parse(RemoveTypeSuffix(valueString.Substring("0x".Length)), System.Globalization.NumberStyles.HexNumber);
                                else
                                        value = SByte.Parse(RemoveTypeSuffix(valueString));
                break;
            case AttributeKind.ShortAttr:
                if(valueString.StartsWith("0x"))
                    value = Int16.Parse(RemoveTypeSuffix(valueString.Substring("0x".Length)), System.Globalization.NumberStyles.HexNumber);
                                else
                                        value = Int16.Parse(RemoveTypeSuffix(valueString));
                break;
            case AttributeKind.IntegerAttr:
                if(valueString.StartsWith("0x"))
                    value = Int32.Parse(valueString.Substring("0x".Length), System.Globalization.NumberStyles.HexNumber);
                                else
                                        value = Int32.Parse(valueString);
                break;
            case AttributeKind.LongAttr:
                if(valueString.StartsWith("0x"))
                    value = Int64.Parse(RemoveTypeSuffix(valueString.Substring("0x".Length)), System.Globalization.NumberStyles.HexNumber);
                                else
                                        value = Int64.Parse(RemoveTypeSuffix(valueString));
                break;
            case AttributeKind.StringAttr:
                value = valueString;
                break;
            case AttributeKind.FloatAttr:
                                if(valueString[valueString.Length-1]=='f') // cut f suffix (required, but be tolerant to incorrect format of pre 2.6RC3, so here optional)
                                        valueString = valueString.Substring(0, valueString.Length-1);
                value = Single.Parse(valueString, System.Globalization.CultureInfo.InvariantCulture);
                break;
            case AttributeKind.DoubleAttr:
                                if(valueString[valueString.Length-1]=='d') // cut d suffix if given
                                        valueString = valueString.Substring(0, valueString.Length-1);
                                value = Double.Parse(valueString, System.Globalization.CultureInfo.InvariantCulture);
                break;
            case AttributeKind.ObjectAttr:
                                if(valueString!="null")
                        throw new Exception("(Non-null) Object attributes unsupported");
                                value = null;
                                break;
            case AttributeKind.GraphAttr:
                                if(valueString!="null")
                        throw new Exception("(Non-null) Graph attributes unsupported");
                                value = null;
                                break;
                        case AttributeKind.NodeAttr:
                                if((valueString[2]=='\"' || valueString[2]=='\'') && (valueString[valueString.Length-2]=='\"' || valueString[valueString.Length-2]=='\''))
                                        value = GetNodeByName(valueString.Substring(3, valueString.Length-5));
                                else
                                        value = GetNodeByName(valueString.Substring(2, valueString.Length-3));
                                break;
                        case AttributeKind.EdgeAttr:
                                if((valueString[2]=='\"' || valueString[2]=='\'') && (valueString[valueString.Length-2]=='\"' || valueString[valueString.Length-2]=='\''))
                                        value = GetEdgeByName(valueString.Substring(3, valueString.Length-5));
                                else
                                        value = GetEdgeByName(valueString.Substring(2, valueString.Length-3));
                                break;
            }
            return value;
        }

                private String RemoveTypeSuffix(String value)
                {
                        if(value.EndsWith("y") || value.EndsWith("Y")
                                || value.EndsWith("s") || value.EndsWith("S")
                                || value.EndsWith("l") || value.EndsWith("L"))
                                return value.Substring(0, value.Length-1);
                        else
                                return value;
                }

                private object ParseAttributeValue(AttributeType attrType, String valueString) // not set/map/array
        {
            object value = null;
            if(attrType.Kind==AttributeKind.EnumAttr)
            {
                                if(valueString.IndexOf("::")!=-1) {
                                        valueString = valueString.Substring(valueString.IndexOf("::")+"::".Length);
                                }

                int val;
                if(Int32.TryParse(valueString, out val)) {
                    value = Enum.ToObject(attrType.EnumType.EnumType, val);
                } else {
                    value = Enum.Parse(attrType.EnumType.EnumType, valueString);
                }
                if(value == null) {
                    throw new Exception("Unknown enum member");
                }
            }
            else
            {
                                value = ParseAttributeValue(attrType.Kind, valueString);
            }
            return value;
        }

        private void SetAttributes(IGraphElement elem, ArrayList attributes)
        {
            foreach(Param par in attributes)
            {
                AttributeType attrType = elem.Type.GetAttributeType(par.Key);
                object value = null;
                IDictionary setmap = null;
                                IList array = null;
                switch(attrType.Kind)
                {
                case AttributeKind.SetAttr:
                        if(par.Value!="set") throw new Exception("Set literal expected");
                        setmap = DictionaryListHelper.NewDictionary(
                            DictionaryListHelper.GetTypeFromNameForDictionaryOrList(par.Type, graph),
                            typeof(de.unika.ipd.grGen.libGr.SetValueType));
                        foreach(object val in par.Values)
                        {
                        setmap.Add( ParseAttributeValue(attrType.ValueType, (String)val), null );
                        }
                        value = setmap;
                        break;
                case AttributeKind.MapAttr:
                        if(par.Value!="map") throw new Exception("Map literal expected");
                        setmap = DictionaryListHelper.NewDictionary(
                            DictionaryListHelper.GetTypeFromNameForDictionaryOrList(par.Type, graph),
                            DictionaryListHelper.GetTypeFromNameForDictionaryOrList(par.TgtType, graph));
                        IEnumerator tgtValEnum = par.TgtValues.GetEnumerator();
                        foreach(object val in par.Values)
                        {
                            tgtValEnum.MoveNext();
                        setmap.Add( ParseAttributeValue(attrType.KeyType, (String)val),
                            ParseAttributeValue(attrType.ValueType, (String)tgtValEnum.Current) );
                        }
                        value = setmap;
                        break;
                                case AttributeKind.ArrayAttr:
                                        if(par.Value!="array") throw new Exception("Array literal expected");
                                        array = DictionaryListHelper.NewList(
                                                DictionaryListHelper.GetTypeFromNameForDictionaryOrList(par.Type, graph));
                                        foreach(object val in par.Values)
                                        {
                                                array.Add( ParseAttributeValue(attrType.ValueType, (String)val) );
                                        }
                                        value = array;
                                        break;
                                default:
                                        value = ParseAttributeValue(attrType, par.Value);
                                        break;
                }

                AttributeChangeType changeType = AttributeChangeType.Assign;
                if (elem is INode)
                    graph.ChangingNodeAttribute((INode)elem, attrType, changeType, value, null);
                else
                    graph.ChangingEdgeAttribute((IEdge)elem, attrType, changeType, value, null);
                elem.SetAttribute(par.Key, value);
            }
        }

  public String Word() {
    Token tok;
    tok = mcc_consume_token(WORD);
        {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String Text() {
        Token tok;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDTEXT:
      tok = mcc_consume_token(DOUBLEQUOTEDTEXT);
      break;
    case SINGLEQUOTEDTEXT:
      tok = mcc_consume_token(SINGLEQUOTEDTEXT);
      break;
    case WORD:
      tok = mcc_consume_token(WORD);
      break;
    default:
      mcc_la1[0] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
                {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String AttributeValue() {
        Token tok;
        String enumName, enumValue;
    if (mcc_2_1(2)) {
      enumName = Word();
      mcc_consume_token(DOUBLECOLON);
      enumValue = Word();
                        {return enumName + "::" + enumValue;}
    } else {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOUBLEQUOTEDTEXT:
          tok = mcc_consume_token(DOUBLEQUOTEDTEXT);
          break;
        case SINGLEQUOTEDTEXT:
          tok = mcc_consume_token(SINGLEQUOTEDTEXT);
          break;
        case WORD:
          tok = mcc_consume_token(WORD);
          break;
        case NUMBER:
          tok = mcc_consume_token(NUMBER);
          break;
        case NUMBER_BYTE:
          tok = mcc_consume_token(NUMBER_BYTE);
          break;
        case NUMBER_SHORT:
          tok = mcc_consume_token(NUMBER_SHORT);
          break;
        case NUMBER_LONG:
          tok = mcc_consume_token(NUMBER_LONG);
          break;
        case HEXNUMBER:
          tok = mcc_consume_token(HEXNUMBER);
          break;
        case HEXNUMBER_BYTE:
          tok = mcc_consume_token(HEXNUMBER_BYTE);
          break;
        case HEXNUMBER_SHORT:
          tok = mcc_consume_token(HEXNUMBER_SHORT);
          break;
        case HEXNUMBER_LONG:
          tok = mcc_consume_token(HEXNUMBER_LONG);
          break;
        case NUMFLOAT:
          tok = mcc_consume_token(NUMFLOAT);
          break;
        case NUMDOUBLE:
          tok = mcc_consume_token(NUMDOUBLE);
          break;
        case TRUE:
          tok = mcc_consume_token(TRUE);
          break;
        case FALSE:
          tok = mcc_consume_token(FALSE);
          break;
        case NULL:
          tok = mcc_consume_token(NULL);
          break;
        default:
          mcc_la1[1] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
                        {return tok.image;}
        break;
      default:
        mcc_la1[2] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Exception("Missing return statement in function");
  }

  public String Filename() {
    Token tok;
     token_source.SwitchTo(WithinFilename);
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDFILENAME:
      tok = mcc_consume_token(DOUBLEQUOTEDFILENAME);
      break;
    case SINGLEQUOTEDFILENAME:
      tok = mcc_consume_token(SINGLEQUOTEDFILENAME);
      break;
    case FILENAME:
      tok = mcc_consume_token(FILENAME);
      break;
    default:
      mcc_la1[3] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
                {return tok.image.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);}
    throw new Exception("Missing return statement in function");
  }

  public INode Node() {
        String str;
    mcc_consume_token(AT);
    mcc_consume_token(LPARENTHESIS);
    str = Text();
    mcc_consume_token(RPARENTHESIS);
                                 {return GetNodeByName(str);}
    throw new Exception("Missing return statement in function");
  }

  public IEdge Edge() {
        String str;
    mcc_consume_token(AT);
    mcc_consume_token(LPARENTHESIS);
    str = Text();
    mcc_consume_token(RPARENTHESIS);
                                 {return GetEdgeByName(str);}
    throw new Exception("Missing return statement in function");
  }

  public IGraphElement GraphElement() {
        String str;
    mcc_consume_token(AT);
    mcc_consume_token(LPARENTHESIS);
    str = Text();
    mcc_consume_token(RPARENTHESIS);
                                 {return GetElemByName(str);}
    throw new Exception("Missing return statement in function");
  }

  public void LineEnd() {
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NL:
      mcc_consume_token(NL);
      break;
    case 0:
      mcc_consume_token(0);
      break;
    default:
      mcc_la1[4] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public bool ParseGraphBuildingScript() {
        String modelFilename, graphName="";
        INode srcNode, tgtNode;
        ElementDef elemDef;
        IGraphElement elem;
        String attrName;
        ArrayList defrAttrInit;
        String index, value;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NEW:
      mcc_consume_token(NEW);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case GRAPH:
        mcc_consume_token(GRAPH);
        modelFilename = Filename();
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOUBLEQUOTEDTEXT:
        case SINGLEQUOTEDTEXT:
        case WORD:
          graphName = Text();
          break;
        default:
          mcc_la1[5] = mcc_gen;
          ;
          break;
        }
        LineEnd();
                                if(modelOverride!=null) {
                                        modelFilename = modelOverride;
                                } else {
                                        modelFilename += ".gm";
                                }
                                if(model!=null) {
                                        graph = backend.CreateNamedGraph(model, graphName);
                                } else {
                                        if(modelFilename.EndsWith(".grg"))
                                        {
                                                backend.CreateNamedFromSpec(modelFilename, graphName, ProcessSpecFlags.UseNoExistingFiles, new List<String>(),
                                                        out graph, out actions);
                                        }
                                        else
                                        {
                                                graph = backend.CreateNamedGraph(modelFilename, graphName);
                                        }
                                }
                        {return true;}
        break;
      default:
        mcc_la1[6] = mcc_gen;
        if (mcc_2_2(2)) {
          srcNode = Node();
          mcc_consume_token(MINUS);
          elemDef = ElementDefinition();
          mcc_consume_token(ARROW);
          tgtNode = Node();
          LineEnd();
                                NewEdge(elemDef, srcNode, tgtNode);
                                {return true;}
        } else if (mcc_2_3(2)) {
          elemDef = ElementDefinition();
          LineEnd();
                                NewNode(elemDef);
                                {return true;}
        } else {
          mcc_consume_token(-1);
          throw new ParseException();
        }
        break;
      }
      break;
    default:
      mcc_la1[7] = mcc_gen;
      if (mcc_2_4(3)) {
        elem = GraphElement();
        mcc_consume_token(56);
                                                       defrAttrInit = new ArrayList();
        SingleAttribute(defrAttrInit);
        LineEnd();
                                DeferredAttributeInitialization(elem, defrAttrInit);
                                {return true;}
      } else {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case AT:
          elem = GraphElement();
          mcc_consume_token(56);
          attrName = Text();
          mcc_consume_token(LBOXBRACKET);
          index = AttributeValue();
          mcc_consume_token(RBOXBRACKET);
          mcc_consume_token(EQUAL);
          value = AttributeValue();
          LineEnd();
                                DeferredAttributeInitialization(elem, attrName, index, value);
                                {return true;}
          break;
        case NL:
          mcc_consume_token(NL);
                        {return true;}
          break;
        case 0:
          mcc_consume_token(0);
                        {return false;}
          break;
        default:
          mcc_la1[8] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    }
    throw new Exception("Missing return statement in function");
  }

  public ElementDef ElementDefinition() {
        String typeName = null, elemName = null;
        ArrayList attributes = new ArrayList();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case 57:
      mcc_consume_token(57);
      typeName = Text();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case LPARENTHESIS:
        mcc_consume_token(LPARENTHESIS);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOUBLEQUOTEDTEXT:
        case SINGLEQUOTEDTEXT:
        case WORD:
        case 58:
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case 58:
            mcc_consume_token(58);
            mcc_consume_token(EQUAL);
            elemName = Text();
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case COMMA:
              mcc_consume_token(COMMA);
              Attributes(attributes);
              break;
            default:
              mcc_la1[9] = mcc_gen;
              ;
              break;
            }
            break;
          case DOUBLEQUOTEDTEXT:
          case SINGLEQUOTEDTEXT:
          case WORD:
            Attributes(attributes);
            break;
          default:
            mcc_la1[10] = mcc_gen;
            mcc_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          mcc_la1[11] = mcc_gen;
          ;
          break;
        }
        mcc_consume_token(RPARENTHESIS);
        break;
      default:
        mcc_la1[12] = mcc_gen;
        ;
        break;
      }
      break;
    default:
      mcc_la1[13] = mcc_gen;
      ;
      break;
    }
                {return new ElementDef(elemName, typeName, attributes);}
    throw new Exception("Missing return statement in function");
  }

  public void Attributes(ArrayList attributes) {
    SingleAttribute(attributes);
    while (true) {
      if (mcc_2_5(2)) {
        ;
      } else {
        goto label_1;
      }
      mcc_consume_token(COMMA);
      SingleAttribute(attributes);
    }label_1: ;
    
  }

  public void SingleAttribute(ArrayList attributes) {
        String attribName, value, valueTgt;
        Token type, typeTgt;
        Param param;
    attribName = Text();
    mcc_consume_token(EQUAL);
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case NUMBER:
    case NUMBER_BYTE:
    case NUMBER_SHORT:
    case NUMBER_LONG:
    case HEXNUMBER:
    case HEXNUMBER_BYTE:
    case HEXNUMBER_SHORT:
    case HEXNUMBER_LONG:
    case NUMFLOAT:
    case NUMDOUBLE:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      value = AttributeValue();
                                attributes.Add(new Param(attribName, value));
      break;
    case SET:
      mcc_consume_token(SET);
      mcc_consume_token(LANGLE);
      type = mcc_consume_token(WORD);
      mcc_consume_token(RANGLE);
                          param = new Param(attribName, "set", type.image);
      mcc_consume_token(LBRACE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        value = AttributeValue();
                                                            param.Values.Add(value);
        break;
      default:
        mcc_la1[14] = mcc_gen;
        ;
        break;
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[15] = mcc_gen;
          goto label_2;
        }
        mcc_consume_token(COMMA);
        value = AttributeValue();
                                                              param.Values.Add(value);
      }label_2: ;
      
      mcc_consume_token(RBRACE);
                          attributes.Add(param);
      break;
    case MAP:
      mcc_consume_token(MAP);
      mcc_consume_token(LANGLE);
      type = mcc_consume_token(WORD);
      mcc_consume_token(COMMA);
      typeTgt = mcc_consume_token(WORD);
      mcc_consume_token(RANGLE);
                          param = new Param(attribName, "map", type.image, typeTgt.image);
      mcc_consume_token(LBRACE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        value = AttributeValue();
                                                            param.Values.Add(value);
        mcc_consume_token(ARROW);
        valueTgt = AttributeValue();
                                                                                                                           param.TgtValues.Add(valueTgt);
        break;
      default:
        mcc_la1[16] = mcc_gen;
        ;
        break;
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[17] = mcc_gen;
          goto label_3;
        }
        mcc_consume_token(COMMA);
        value = AttributeValue();
                                                                   param.Values.Add(value);
        mcc_consume_token(ARROW);
        valueTgt = AttributeValue();
                                                                                                                                  param.TgtValues.Add(valueTgt);
      }label_3: ;
      
      mcc_consume_token(RBRACE);
                          attributes.Add(param);
      break;
    case ARRAY:
      mcc_consume_token(ARRAY);
      mcc_consume_token(LANGLE);
      type = mcc_consume_token(WORD);
      mcc_consume_token(RANGLE);
                          param = new Param(attribName, "array", type.image);
      mcc_consume_token(LBOXBRACKET);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        value = AttributeValue();
                                                                 param.Values.Add(value);
        break;
      default:
        mcc_la1[18] = mcc_gen;
        ;
        break;
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[19] = mcc_gen;
          goto label_4;
        }
        mcc_consume_token(COMMA);
        value = AttributeValue();
                                                              param.Values.Add(value);
      }label_4: ;
      
      mcc_consume_token(RBOXBRACKET);
                          attributes.Add(param);
      break;
    default:
      mcc_la1[20] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  private bool mcc_2_1(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_1(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(0, xla); }
  }

  private bool mcc_2_2(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_2(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(1, xla); }
  }

  private bool mcc_2_3(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_3(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(2, xla); }
  }

  private bool mcc_2_4(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_4(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(3, xla); }
  }

  private bool mcc_2_5(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_5(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(4, xla); }
  }

  private bool mcc_3R_11() {
    if (mcc_scan_token(57)) return true;
    if (mcc_3R_12()) return true;
    return false;
  }

  private bool mcc_3R_10() {
    if (mcc_3R_12()) return true;
    return false;
  }

  private bool mcc_3R_9() {
    if (mcc_scan_token(AT)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_12()) return true;
    return false;
  }

  private bool mcc_3_4() {
    if (mcc_3R_9()) return true;
    return false;
  }

  private bool mcc_3_5() {
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_10()) return true;
    return false;
  }

  private bool mcc_3R_7() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_11()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_5() {
    if (mcc_scan_token(WORD)) return true;
    return false;
  }

  private bool mcc_3_3() {
    if (mcc_3R_7()) return true;
    if (mcc_3R_8()) return true;
    return false;
  }

  private bool mcc_3_2() {
    if (mcc_3R_6()) return true;
    return false;
  }

  private bool mcc_3R_12() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(44)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(45)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(46)) return true;
    }
    }
    return false;
  }

  private bool mcc_3R_8() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(7)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(0)) return true;
    }
    return false;
  }

  private bool mcc_3R_6() {
    if (mcc_scan_token(AT)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3_1() {
    if (mcc_3R_5()) return true;
    if (mcc_scan_token(DOUBLECOLON)) return true;
    return false;
  }

  public GRSImporterTokenManager token_source;
  SimpleCharStream mcc_input_stream;
  public Token token, mcc_nt;
  private int mcc_ntk;
  private Token mcc_scanpos, mcc_lastpos;
  private int mcc_la;
  public bool lookingAhead = false;
  private bool mcc_semLA;
  private int mcc_gen;
  private int[] mcc_la1 = new int[21];
  static private int[] mcc_la1_0;
  static private int[] mcc_la1_1;
  static GRSImporter() {
      mcc_gla1_0();
      mcc_gla1_1();
   }
   private static void mcc_gla1_0() {
      mcc_la1_0 = new int[] {0,822083584,822083584,0,129,0,33554432,67108864,131201,4096,0,0,32768,0,822083584,4096,822083584,4096,822083584,4096,-251658240,};
   }
   private static void mcc_gla1_1() {
      mcc_la1_1 = new int[] {28672,30718,30718,3670016,0,28672,0,0,0,0,67137536,67137536,0,33554432,30718,0,30718,0,30718,0,30719,};
   }
  private MccCalls[] mcc_2_rtns = new MccCalls[5];
  private bool mcc_rescan = false;
  private int mcc_gc = 0;

  public GRSImporter(System.IO.Stream stream) {
    mcc_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new GRSImporterTokenManager(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 21; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public void ReInit(System.IO.Stream stream) {
    mcc_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 21; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public GRSImporter(System.IO.TextReader stream) {
    mcc_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new GRSImporterTokenManager(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 21; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public void ReInit(System.IO.TextReader stream) {
    mcc_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 21; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public GRSImporter(GRSImporterTokenManager tm) {
    token_source = tm;
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 21; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public void ReInit(GRSImporterTokenManager tm) {
    token_source = tm;
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 21; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

   private Token mcc_consume_token(int kind) {
    Token oldToken = null;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.GetNextToken();
    mcc_ntk = -1;
    if (token.kind == kind) {
      mcc_gen++;
      if (++mcc_gc > 100) {
        mcc_gc = 0;
        for (int i = 0; i < mcc_2_rtns.Length; i++) {
          MccCalls c = mcc_2_rtns[i];
          while (c != null) {
            if (c.gen < mcc_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    mcc_kind = kind;
    throw GenerateParseException();
  }

  private class LookaheadSuccess : System.Exception { }
  private LookaheadSuccess mcc_ls = new LookaheadSuccess();
  private bool mcc_scan_token(int kind) {
    if (mcc_scanpos == mcc_lastpos) {
      mcc_la--;
      if (mcc_scanpos.next == null) {
        mcc_lastpos = mcc_scanpos = mcc_scanpos.next = token_source.GetNextToken();
      } else {
        mcc_lastpos = mcc_scanpos = mcc_scanpos.next;
      }
    } else {
      mcc_scanpos = mcc_scanpos.next;
    }
    if (mcc_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != mcc_scanpos) { i++; tok = tok.next; }
      if (tok != null) mcc_add_error_token(kind, i);
    }
    if (mcc_scanpos.kind != kind) return true;
    if (mcc_la == 0 && mcc_scanpos == mcc_lastpos) throw mcc_ls;
    return false;
  }

  public Token GetNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.GetNextToken();
    mcc_ntk = -1;
    mcc_gen++;
    return token;
  }

  public Token GetToken(int index) {
    Token t = lookingAhead ? mcc_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.GetNextToken();
    }
    return t;
  }

  private int mcc_mntk() {
    if ((mcc_nt=token.next) == null)
      return (mcc_ntk = (token.next=token_source.GetNextToken()).kind);
    else
      return (mcc_ntk = mcc_nt.kind);
  }

  private System.Collections.ArrayList mcc_expentries = new System.Collections.ArrayList();
  private int[] mcc_expentry;
  private int mcc_kind = -1;
  private int[] mcc_lasttokens = new int[100];
  private int mcc_endpos;

  private void mcc_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == mcc_endpos + 1) {
      mcc_lasttokens[mcc_endpos++] = kind;
    } else if (mcc_endpos != 0) {
      mcc_expentry = new int[mcc_endpos];
      for (int i = 0; i < mcc_endpos; i++) {
        mcc_expentry[i] = mcc_lasttokens[i];
      }
      bool exists = false;
      for (System.Collections.IEnumerator e = mcc_expentries.GetEnumerator(); e.MoveNext();) {
        int[] oldentry = (int[])e.Current;
        if (oldentry.Length == mcc_expentry.Length) {
          exists = true;
          for (int i = 0; i < mcc_expentry.Length; i++) {
            if (oldentry[i] != mcc_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) mcc_expentries.Add(mcc_expentry);
      if (pos != 0) mcc_lasttokens[(mcc_endpos = pos) - 1] = kind;
    }
  }

  public ParseException GenerateParseException() {
    mcc_expentries.Clear();
    bool[] la1tokens = new bool[59];
    for (int i = 0; i < 59; i++) {
      la1tokens[i] = false;
    }
    if (mcc_kind >= 0) {
      la1tokens[mcc_kind] = true;
      mcc_kind = -1;
    }
    for (int i = 0; i < 21; i++) {
      if (mcc_la1[i] == mcc_gen) {
        for (int j = 0; j < 32; j++) {
          if ((mcc_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((mcc_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 59; i++) {
      if (la1tokens[i]) {
        mcc_expentry = new int[1];
        mcc_expentry[0] = i;
        mcc_expentries.Add(mcc_expentry);
      }
    }
    mcc_endpos = 0;
    mcc_rescan_token();
    mcc_add_error_token(0, 0);
    int[][] exptokseq = new int[mcc_expentries.Count][];
    for (int i = 0; i < mcc_expentries.Count; i++) {
      exptokseq[i] = (int[])mcc_expentries[i];
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  public void enable_tracing() {
  }

  public void disable_tracing() {
  }

  private void mcc_rescan_token() {
    mcc_rescan = true;
    for (int i = 0; i < 5; i++) {
      MccCalls p = mcc_2_rtns[i];
      do {
        if (p.gen > mcc_gen) {
          mcc_la = p.arg; mcc_lastpos = mcc_scanpos = p.first;
          switch (i) {
            case 0: mcc_3_1(); break;
            case 1: mcc_3_2(); break;
            case 2: mcc_3_3(); break;
            case 3: mcc_3_4(); break;
            case 4: mcc_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    mcc_rescan = false;
  }

  private void mcc_save(int index, int xla) {
    MccCalls p = mcc_2_rtns[index];
    while (p.gen > mcc_gen) {
      if (p.next == null) { p = p.next = new MccCalls(); break; }
      p = p.next;
    }
    p.gen = mcc_gen + xla - mcc_la; p.first = token; p.arg = xla;
  }

  class MccCalls {
    public int gen;
    public Token first;
    public int arg;
    public MccCalls next;
  }

    }
}
