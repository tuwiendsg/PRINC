/* Generated By:CSharpCC: Do not edit this line. SequenceParser.cs */
        namespace de.unika.ipd.grGen.libGr.sequenceParser {

        using System;
        using System.IO;
        using System.Collections;
        using System.Collections.Generic;
        using de.unika.ipd.grGen.libGr;

        /// <summary>
        /// A parser class for xgrs strings.
        /// </summary>
        public class SequenceParser : SequenceParserConstants {
                /// <summary>
                /// The rules and sequences used in the specification, set if parsing an xgrs to be interpreted
                /// </summary>
                BaseActions actions;

                /// <summary>
                /// The names of the rules used in the specification, set if parsing an xgrs to be compiled
                /// </summary>
                String[] ruleNames;

                /// <summary>
                /// The names of the sequences used in the specification, set if parsing an xgrs to be compiled
                /// </summary>
                String[] sequenceNames;

                /// <summary>
                /// The model used in the specification
                /// </summary>
                IGraphModel model;

                /// <summary>
                /// Symbol table of the sequence variables, maps from name to the prefixed(by block nesting) name and the type;
                /// a graph-global variable maps to type "", a sequence-local to its type
                /// </summary>
                SymbolTable varDecls;

                /// <summary>
                /// Stores the warnings which occur during parsing
                /// </summary>
                List<String> warnings;

        /// <summary>
        /// Parses a given string in xgrs syntax and builds a Sequence object. Used for the interpreted xgrs.
        /// </summary>
        /// <param name="sequenceStr">The string representing a xgrs (e.g. "test[7] &amp;&amp; (chicken+ || egg)*")</param>
        /// <param name="actions">The BaseActions object containing the rules used in the string.</param>
        /// <param name="warnings">A list which receives the warnings generated during parsing.</param>
        /// <returns>The sequence object according to sequenceStr.</returns>
        /// <exception cref="ParseException">Thrown when a syntax error was found in the string.</exception>
        /// <exception cref="SequenceParserException">Thrown when a rule is used with the wrong number of arguments
        /// or return parameters.</exception>
                public static Sequence ParseSequence(String sequenceStr, BaseActions actions, List<String> warnings)
                {
                        SequenceParser parser = new SequenceParser(new StringReader(sequenceStr));
                        parser.actions = actions;
                        parser.ruleNames = null;
                        parser.model = actions.Graph.Model;
                        parser.varDecls = new SymbolTable();
                        parser.varDecls.PushFirstScope(null);
                        parser.warnings = warnings;
                        Sequence seq = parser.XGRS();
                        SequenceCheckingEnvironment env = new SequenceCheckingEnvironmentInterpreted(actions);
                        seq.Check(env);
                        return seq;
                }

        /// <summary>
        /// Parses a given string in sequence definition syntax and builds a SequenceDefinition object. Used for the interpreted xgrs.
        /// </summary>
        /// <param name="sequenceStr">The string representing a xgrs (e.g. "test[7] &amp;&amp; (chicken+ || egg)*")</param>
        /// <param name="actions">The BaseActions object containing the rules used in the string.</param>
        /// <param name="warnings">A list which receives the warnings generated during parsing.</param>
        /// <returns>The sequence object according to sequenceStr.</returns>
        /// <exception cref="ParseException">Thrown when a syntax error was found in the string.</exception>
        /// <exception cref="SequenceParserException">Thrown when a rule is used with the wrong number of arguments
        /// or return parameters.</exception>
                public static SequenceDefinition ParseSequenceDefinition(String sequenceStr, BaseActions actions, List<String> warnings)
                {
                        SequenceParser parser = new SequenceParser(new StringReader(sequenceStr));
                        parser.actions = actions;
                        parser.ruleNames = null;
                        parser.model = actions.Graph.Model;
                        parser.varDecls = new SymbolTable();
                        parser.varDecls.PushFirstScope(null);
                        parser.warnings = warnings;
                        SequenceDefinition seq = parser.defXGRS();
                        SequenceCheckingEnvironment env = new SequenceCheckingEnvironmentInterpreted(actions);
                        seq.Check(env);
                        return seq;
                }

        /// <summary>
        /// Parses a given string in xgrs syntax and builds a Sequence object. Used for the compiled xgrs.
        /// </summary>
        /// <param name="sequenceStr">The string representing a xgrs (e.g. "test[7] &amp;&amp; (chicken+ || egg)*")</param>
        /// <param name="ruleNames">An array containing the names of the rules used in the specification.</param>
        /// <param name="sequenceNames">An array containing the names of the sequences used in the specification.</param>
        /// <param name="predefinedVariables">A map from variables to types giving the parameters to the sequence, i.e. predefined variables.</param>
        /// <param name="model">The model used in the specification.</param>
        /// <param name="warnings">A list which receives the warnings generated during parsing.</param>
        /// <returns>The sequence object according to sequenceStr.</returns>
        /// <exception cref="ParseException">Thrown when a syntax error was found in the string.</exception>
        /// <exception cref="SequenceParserException">Thrown when a rule is used with the wrong number of arguments
        /// or return parameters.</exception>
                public static Sequence ParseSequence(String sequenceStr, String[] ruleNames, String[] sequenceNames,
                        Dictionary<String, String> predefinedVariables, IGraphModel model, List<String> warnings)
                {
                        SequenceParser parser = new SequenceParser(new StringReader(sequenceStr));
                        parser.actions = null;
                        parser.ruleNames = ruleNames;
                        parser.sequenceNames = sequenceNames;
                        parser.model = model;
                        parser.varDecls = new SymbolTable();
                        parser.varDecls.PushFirstScope(predefinedVariables);
                        parser.warnings = warnings;
                        Sequence seq = parser.XGRS();
                        // check will be done by LGSPSequenceChecker from lgsp code afterwards outside of this libGr code
                        return seq;
                }

  public String Word() {
        Token tok;
    tok = mcc_consume_token(WORD);
                {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String TextString() {
        Token tok;
    tok = mcc_consume_token(DOUBLEQUOTEDTEXT);
                {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String Text() {
        Token tok;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDTEXT:
      tok = mcc_consume_token(DOUBLEQUOTEDTEXT);
      break;
    case SINGLEQUOTEDTEXT:
      tok = mcc_consume_token(SINGLEQUOTEDTEXT);
      break;
    case WORD:
      tok = mcc_consume_token(WORD);
      break;
    default:
      mcc_la1[0] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
                {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public int Number() {
        Token t;
        int val;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NUMBER:
      t = mcc_consume_token(NUMBER);
                        if(!Int32.TryParse(t.image, out val))
                                {throw new ParseException("Integer expected but found: \"" + t + "\" (" + t.kind + ")");}
                        {return val;}
      break;
    case HEXNUMBER:
      t = mcc_consume_token(HEXNUMBER);
                        {return Int32.Parse(t.image.Substring("0x".Length), System.Globalization.NumberStyles.HexNumber);}
      break;
    default:
      mcc_la1[1] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public float FloatNumber() {
        Token t;
        float val;
    t = mcc_consume_token(NUMFLOAT);
                // Remove 'F' from the end of the image to parse it
                if(!float.TryParse(t.image.Substring(0, t.image.Length - 1), System.Globalization.NumberStyles.Float,
                                System.Globalization.CultureInfo.InvariantCulture, out val))
                        {throw new ParseException("float expected but found: \"" + t + "\" (" + t.kind + ")");}
                {return val;}
    throw new Exception("Missing return statement in function");
  }

  public double DoubleNumber() {
        Token t;
        String img;
        double val;
    t = mcc_consume_token(NUMDOUBLE);
                // Remove optional 'D' from the end of the image to parse it if necessary
                if(t.image[t.image.Length - 1] == 'd' || t.image[t.image.Length - 1] == 'D')
                        img = t.image.Substring(0, t.image.Length - 1);
                else
                        img = t.image;
                if(!double.TryParse(img, System.Globalization.NumberStyles.Float,
                                System.Globalization.CultureInfo.InvariantCulture, out val))
                        {throw new ParseException("double expected but found: \"" + t + "\" (" + t.kind + ")");}
                {return val;}
    throw new Exception("Missing return statement in function");
  }

  public void Argument(List<SequenceExpression> argExprs) {
        SequenceExpression expr;
    expr = Expression();
                argExprs.Add(expr);
  }

  public object SimpleConstant() {
        object constant = null;
        Token tok;
        string type, value;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NUMBER:
    case NUMBER_BYTE:
    case NUMBER_SHORT:
    case NUMBER_LONG:
    case HEXNUMBER:
    case HEXNUMBER_BYTE:
    case HEXNUMBER_SHORT:
    case HEXNUMBER_LONG:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NUMBER:
        tok = mcc_consume_token(NUMBER);
                               constant = Convert.ToInt32(tok.image);
        break;
      case NUMBER_BYTE:
        tok = mcc_consume_token(NUMBER_BYTE);
                                      constant = Convert.ToSByte(RemoveTypeSuffix(tok.image));
        break;
      case NUMBER_SHORT:
        tok = mcc_consume_token(NUMBER_SHORT);
                                       constant = Convert.ToInt16(RemoveTypeSuffix(tok.image));
        break;
      case NUMBER_LONG:
        tok = mcc_consume_token(NUMBER_LONG);
                                      constant = Convert.ToInt64(RemoveTypeSuffix(tok.image));
        break;
      case HEXNUMBER:
        tok = mcc_consume_token(HEXNUMBER);
                                    constant = Int32.Parse(tok.image.Substring("0x".Length), System.Globalization.NumberStyles.HexNumber);
        break;
      case HEXNUMBER_BYTE:
        tok = mcc_consume_token(HEXNUMBER_BYTE);
                                         constant = SByte.Parse(RemoveTypeSuffix(tok.image.Substring("0x".Length)), System.Globalization.NumberStyles.HexNumber);
        break;
      case HEXNUMBER_SHORT:
        tok = mcc_consume_token(HEXNUMBER_SHORT);
                                          constant = Int16.Parse(RemoveTypeSuffix(tok.image.Substring("0x".Length)), System.Globalization.NumberStyles.HexNumber);
        break;
      case HEXNUMBER_LONG:
        tok = mcc_consume_token(HEXNUMBER_LONG);
                                         constant = Int64.Parse(RemoveTypeSuffix(tok.image.Substring("0x".Length)), System.Globalization.NumberStyles.HexNumber);
        break;
      default:
        mcc_la1[2] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    case NUMFLOAT:
      constant = FloatNumber();
      break;
    case NUMDOUBLE:
      constant = DoubleNumber();
      break;
    case DOUBLEQUOTEDTEXT:
      constant = TextString();
      break;
    case TRUE:
      mcc_consume_token(TRUE);
                         constant = true;
      break;
    case FALSE:
      mcc_consume_token(FALSE);
                          constant = false;
      break;
    case NULL:
      mcc_consume_token(NULL);
                         constant = null;
      break;
    default:
      mcc_la1[3] = mcc_gen;
      if (mcc_2_1(2)) {
        type = Word();
        mcc_consume_token(DOUBLECOLON);
        value = Word();
                        foreach(EnumAttributeType attrType in model.EnumAttributeTypes)
                        {
                                if(attrType.Name == type)
                                {
                                        Type enumType = attrType.EnumType;
                                        constant = Enum.Parse(enumType, value);
                                        break;
                                }
                        }
                        if(constant==null)
                                {throw new ParseException("Invalid constant \""+type+"::"+value+"\"!");}
      } else if (GetToken(1).kind==WORD && varDecls.Lookup(GetToken(1).image)==null && TypesHelper.GetNodeOrEdgeType(GetToken(1).image, model)!=null) {
        type = Word();
                        {return TypesHelper.GetNodeOrEdgeType(type, model);}
      } else {
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    }
                {return constant;}
    throw new Exception("Missing return statement in function");
  }

  public object Constant() {
        object constant = null;
        object src = null, dst = null;
        string typeName, typeNameDst;
        Type srcType, dstType;
    if (mcc_2_5(1)) {
      constant = SimpleConstant();
    } else {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case SET:
        mcc_consume_token(SET);
        mcc_consume_token(LANGLE);
        typeName = Word();
        mcc_consume_token(RANGLE);
                        srcType = DictionaryListHelper.GetTypeFromNameForDictionaryOrList(typeName, model);
                        dstType = typeof(de.unika.ipd.grGen.libGr.SetValueType);
                        if(srcType!=null)
                                constant = DictionaryListHelper.NewDictionary(srcType, dstType);
                        if(constant==null)
                                {throw new ParseException("Invalid constant \"set<"+typeName+">\"!");}
        mcc_consume_token(LBRACE);
        if (mcc_2_2(1)) {
          src = SimpleConstant();
                                                 ((IDictionary)constant).Add(src, null);
        } else {
          ;
        }
        while (true) {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case COMMA:
            ;
            break;
          default:
            mcc_la1[4] = mcc_gen;
            goto label_1;
          }
          mcc_consume_token(COMMA);
          src = SimpleConstant();
                                                             ((IDictionary)constant).Add(src, null);
        }label_1: ;
        
        mcc_consume_token(RBRACE);
        break;
      case MAP:
        mcc_consume_token(MAP);
        mcc_consume_token(LANGLE);
        typeName = Word();
        mcc_consume_token(COMMA);
        typeNameDst = Word();
        mcc_consume_token(RANGLE);
                        srcType = DictionaryListHelper.GetTypeFromNameForDictionaryOrList(typeName, model);
                        dstType = DictionaryListHelper.GetTypeFromNameForDictionaryOrList(typeNameDst, model);
                        if(srcType!=null && dstType!=null)
                                constant = DictionaryListHelper.NewDictionary(srcType, dstType);
                        if(constant==null)
                                {throw new ParseException("Invalid constant \"map<"+typeName+","+typeNameDst+">\"!");}
        mcc_consume_token(LBRACE);
        if (mcc_2_3(1)) {
          src = SimpleConstant();
          mcc_consume_token(ARROW);
          dst = SimpleConstant();
                                                                           ((IDictionary)constant).Add(src, dst);
        } else {
          ;
        }
        while (true) {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case COMMA:
            ;
            break;
          default:
            mcc_la1[5] = mcc_gen;
            goto label_2;
          }
          mcc_consume_token(COMMA);
          src = SimpleConstant();
          mcc_consume_token(ARROW);
          dst = SimpleConstant();
                                                                                       ((IDictionary)constant).Add(src, dst);
        }label_2: ;
        
        mcc_consume_token(RBRACE);
        break;
      case ARRAY:
        mcc_consume_token(ARRAY);
        mcc_consume_token(LANGLE);
        typeName = Word();
        mcc_consume_token(RANGLE);
                        srcType = DictionaryListHelper.GetTypeFromNameForDictionaryOrList(typeName, model);
                        if(srcType!=null)
                                constant = DictionaryListHelper.NewList(srcType);
                        if(constant==null)
                                {throw new ParseException("Invalid constant \"array<"+typeName+">\"!");}
        mcc_consume_token(LBOXBRACKET);
        if (mcc_2_4(1)) {
          src = SimpleConstant();
                                                 ((IList)constant).Add(src);
        } else {
          ;
        }
        while (true) {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case COMMA:
            ;
            break;
          default:
            mcc_la1[6] = mcc_gen;
            goto label_3;
          }
          mcc_consume_token(COMMA);
          src = SimpleConstant();
                                                             ((IList)constant).Add(src);
        }label_3: ;
        
        mcc_consume_token(RBOXBRACKET);
        break;
      default:
        mcc_la1[7] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    }
                {return constant;}
    throw new Exception("Missing return statement in function");
  }

  public void Arguments(List<SequenceExpression> argExprs) {
    Argument(argExprs);
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case COMMA:
        ;
        break;
      default:
        mcc_la1[8] = mcc_gen;
        goto label_4;
      }
      mcc_consume_token(COMMA);
      Argument(argExprs);
    }label_4: ;
    
  }

  public SequenceVariable Variable() {
        String varName, typeName=null;
        SequenceVariable oldVariable, newVariable;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case WORD:
      varName = Word();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case COLON:
        mcc_consume_token(COLON);
        typeName = Type();
        break;
      default:
        mcc_la1[9] = mcc_gen;
        ;
        break;
      }
                        oldVariable = varDecls.Lookup(varName);
                        if(typeName!=null)
                        {
                                if(oldVariable==null) {
                                        newVariable = varDecls.Define(varName, typeName);
                                } else if(oldVariable.Type=="") {
                                        if(varDecls.WasImplicitelyDeclared(oldVariable))
                                                {throw new ParseException("The variable \""+varName+"\" has already been used/implicitely declared as global variable!");}
                                        else // it was explicitely used as global before, we are allowed to create a local variable with the same name, the global is (only) accessible with global prefix then
                                                newVariable = varDecls.Define(varName, typeName);
                                } else {
                                        {throw new ParseException("The variable \""+varName+"\" has already been declared as local variable with type \""+oldVariable.Type+"\"!");}
                                }
                        }
                        else
                        {
                                if(oldVariable==null) {
                                        newVariable = varDecls.Define(varName, "");
                                        warnings.Add("WARNING: using global variables without \"::\" prefix is deprecated, missing for: " + varName);
                                } else {
                                        if(oldVariable.Type=="")
                                                warnings.Add("WARNING: using global variables without \"::\" prefix is deprecated, missing for: " + varName);
                                        newVariable = oldVariable;
                                }
                        }
                        {return newVariable;}
      break;
    case DOUBLECOLON:
      mcc_consume_token(DOUBLECOLON);
      varName = Word();
                        {return varDecls.LookupDefineGlobal(varName);}
      break;
    default:
      mcc_la1[10] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public SequenceVariable VariableDefinition() {
        String varName, typeName;
    varName = Word();
    mcc_consume_token(COLON);
    typeName = Type();
                SequenceVariable oldVariable = varDecls.Lookup(varName);
                SequenceVariable newVariable;
                if(oldVariable==null) {
                        newVariable = varDecls.Define(varName, typeName);
                } else if(oldVariable.Type=="") {
                        if(varDecls.WasImplicitelyDeclared(oldVariable))
                                {throw new ParseException("The variable \""+varName+"\" has already been used/implicitely declared as global variable!");}
                        else // it was explicitely used as global before, we are allowed to create a local variable with the same name, the global is (only) accessible with global prefix then
                                newVariable = varDecls.Define(varName, typeName);
                } else {
                        {throw new ParseException("The variable \""+varName+"\" has already been declared as local variable with type \""+oldVariable.Type+"\"!");}
                }
                {return newVariable;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceVariable VariableUse() {
        String varName;
        SequenceVariable oldVariable, newVariable;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case WORD:
      varName = Word();
                        oldVariable = varDecls.Lookup(varName);
                        if(oldVariable==null) {
                                newVariable = varDecls.Define(varName, "");
                                warnings.Add("WARNING: using global variables without \"::\" prefix is deprecated, missing for: " + varName);
                        } else {
                                if(oldVariable.Type=="")
                                        warnings.Add("WARNING: using global variables without \"::\" prefix is deprecated, missing for: " + varName);
                                newVariable = oldVariable;
                        }
                        {return newVariable;}
      break;
    case DOUBLECOLON:
      mcc_consume_token(DOUBLECOLON);
      varName = Word();
                        {return varDecls.LookupDefineGlobal(varName);}
      break;
    default:
      mcc_la1[11] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public void VariableList(List<SequenceVariable> variables) {
        SequenceVariable var;
    var = Variable();
                         variables.Add(var);
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case COMMA:
        ;
        break;
      default:
        mcc_la1[12] = mcc_gen;
        goto label_5;
      }
      mcc_consume_token(COMMA);
      var = Variable();
                                                                     variables.Add(var);
    }label_5: ;
    
  }

  public void VariableDefinitionList(List<SequenceVariable> variables) {
        SequenceVariable var;
    var = VariableDefinition();
                                   variables.Add(var);
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case COMMA:
        ;
        break;
      default:
        mcc_la1[13] = mcc_gen;
        goto label_6;
      }
      mcc_consume_token(COMMA);
      var = VariableDefinition();
                                                                                         variables.Add(var);
    }label_6: ;
    
  }

  public String Type() {
        String type;
        String typeParam, typeParamDst;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case WORD:
      type = Word();
      break;
    default:
      mcc_la1[18] = mcc_gen;
      if (mcc_2_8(2147483647)) {
        mcc_consume_token(SET);
        mcc_consume_token(LANGLE);
        typeParam = Word();
        mcc_consume_token(RANGLE);
                                                                           type = "set<"+typeParam+">";
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case LBRACE:
          mcc_consume_token(LBRACE);
                       {throw new ParseException("no {} allowed at set declaration, use s:set<T> = set<T>{} for initialization");}
          break;
        default:
          mcc_la1[14] = mcc_gen;
          ;
          break;
        }
      } else if (mcc_2_9(2147483647)) {
        mcc_consume_token(MAP);
        mcc_consume_token(LANGLE);
        typeParam = Word();
        mcc_consume_token(COMMA);
        typeParamDst = Word();
        mcc_consume_token(RANGLE);
                                                                                                              type = "map<"+typeParam+","+typeParamDst+">";
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case LBRACE:
          mcc_consume_token(LBRACE);
                       {throw new ParseException("no {} allowed at map declaration, use m:map<S,T> = map<S,T>{} for initialization");}
          break;
        default:
          mcc_la1[15] = mcc_gen;
          ;
          break;
        }
      } else if (mcc_2_10(2147483647)) {
        mcc_consume_token(ARRAY);
        mcc_consume_token(LANGLE);
        typeParam = Word();
        mcc_consume_token(RANGLE);
                                                                               type = "array<"+typeParam+">";
        if (mcc_2_6(2)) {
          mcc_consume_token(LBOXBRACKET);
                                    {throw new ParseException("no [] allowed at array declaration, use a:array<T> = array<T>[] for initialization");}
        } else {
          ;
        }
      } else if (mcc_2_11(2147483647)) {
        mcc_consume_token(SET);
        mcc_consume_token(LANGLE);
        typeParam = Word();
                                                                        type = "set<"+typeParam+">";
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case LBRACE:
          mcc_consume_token(LBRACE);
                       {throw new ParseException("no {} allowed at set declaration, use s:set<T> = set<T>{} for initialization");}
          break;
        default:
          mcc_la1[16] = mcc_gen;
          ;
          break;
        }
      } else if (mcc_2_12(2147483647)) {
        mcc_consume_token(MAP);
        mcc_consume_token(LANGLE);
        typeParam = Word();
        mcc_consume_token(COMMA);
        typeParamDst = Word();
                                                                                                           type = "map<"+typeParam+","+typeParamDst+">";
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case LBRACE:
          mcc_consume_token(LBRACE);
                       {throw new ParseException("no {} allowed at map declaration, use m:map<S,T> = map<S,T>{} for initialization");}
          break;
        default:
          mcc_la1[17] = mcc_gen;
          ;
          break;
        }
      } else if (mcc_2_13(2147483647)) {
        mcc_consume_token(ARRAY);
        mcc_consume_token(LANGLE);
        typeParam = Word();
                                                                            type = "array<"+typeParam+">";
        if (mcc_2_7(2)) {
          mcc_consume_token(LBOXBRACKET);
                                    {throw new ParseException("no [] allowed at array declaration, use a:array<T> = array<T>[] for initialization");}
        } else {
          ;
        }
      } else {
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    }
                {return type;}
    throw new Exception("Missing return statement in function");
  }

  public Sequence XGRS() {
        Sequence seq;
    seq = RewriteSequence();
    mcc_consume_token(0);
                {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceDefinition defXGRS() {
        String name;
        List<SequenceVariable> inputVariables = new List<SequenceVariable>();
        List<SequenceVariable> outputVariables = new List<SequenceVariable>();
        Sequence seq;
    name = Word();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case LPARENTHESIS:
      mcc_consume_token(LPARENTHESIS);
      VariableDefinitionList(inputVariables);
      mcc_consume_token(RPARENTHESIS);
      break;
    default:
      mcc_la1[19] = mcc_gen;
      ;
      break;
    }
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case COLON:
      mcc_consume_token(COLON);
      mcc_consume_token(LPARENTHESIS);
      VariableDefinitionList(outputVariables);
      mcc_consume_token(RPARENTHESIS);
      break;
    default:
      mcc_la1[20] = mcc_gen;
      ;
      break;
    }
    mcc_consume_token(LBRACE);
    seq = RewriteSequence();
    mcc_consume_token(RBRACE);
    mcc_consume_token(0);
                {return new SequenceDefinitionInterpreted(name, inputVariables.ToArray(), outputVariables.ToArray(), seq);}
    throw new Exception("Missing return statement in function");
  }

/////////////////////////////////////////
// Extended rewrite sequence           //
// (lowest precedence operators first) //
/////////////////////////////////////////
  public Sequence RewriteSequence() {
        Sequence seq, seq2;
        bool random = false, choice = false;
    seq = RewriteSequenceLazyOr();
    while (true) {
      if (mcc_2_14(3)) {
        ;
      } else {
        goto label_7;
      }
      if (mcc_2_15(3)) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOLLAR:
          mcc_consume_token(DOLLAR);
                               random = true;
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case PERCENT:
            mcc_consume_token(PERCENT);
                                                       choice = true;
            break;
          default:
            mcc_la1[21] = mcc_gen;
            ;
            break;
          }
          break;
        default:
          mcc_la1[22] = mcc_gen;
          ;
          break;
        }
        mcc_consume_token(THENLEFT);
        seq2 = RewriteSequenceLazyOr();
                                seq = new SequenceThenLeft(seq, seq2, random, choice);
      } else {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOLLAR:
        case THENRIGHT:
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case DOLLAR:
            mcc_consume_token(DOLLAR);
                               random = true;
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case PERCENT:
              mcc_consume_token(PERCENT);
                                                       choice = true;
              break;
            default:
              mcc_la1[23] = mcc_gen;
              ;
              break;
            }
            break;
          default:
            mcc_la1[24] = mcc_gen;
            ;
            break;
          }
          mcc_consume_token(THENRIGHT);
          seq2 = RewriteSequenceLazyOr();
                                seq = new SequenceThenRight(seq, seq2, random, choice);
          break;
        default:
          mcc_la1[25] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
      }
    }label_7: ;
    
                {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public Sequence RewriteSequenceLazyOr() {
        Sequence seq, seq2;
        bool random = false, choice = false;
    seq = RewriteSequenceLazyAnd();
    while (true) {
      if (mcc_2_16(3)) {
        ;
      } else {
        goto label_8;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOLLAR:
        mcc_consume_token(DOLLAR);
                       random = true;
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
                                               choice = true;
          break;
        default:
          mcc_la1[26] = mcc_gen;
          ;
          break;
        }
        break;
      default:
        mcc_la1[27] = mcc_gen;
        ;
        break;
      }
      mcc_consume_token(DOUBLEPIPE);
      seq2 = RewriteSequenceLazyAnd();
                        seq = new SequenceLazyOr(seq, seq2, random, choice);
    }label_8: ;
    
                {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public Sequence RewriteSequenceLazyAnd() {
        Sequence seq, seq2;
        bool random = false, choice = false;
    seq = RewriteSequenceStrictOr();
    while (true) {
      if (mcc_2_17(3)) {
        ;
      } else {
        goto label_9;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOLLAR:
        mcc_consume_token(DOLLAR);
                       random = true;
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
                                               choice = true;
          break;
        default:
          mcc_la1[28] = mcc_gen;
          ;
          break;
        }
        break;
      default:
        mcc_la1[29] = mcc_gen;
        ;
        break;
      }
      mcc_consume_token(DOUBLEAMPERSAND);
      seq2 = RewriteSequenceStrictOr();
                        seq = new SequenceLazyAnd(seq, seq2, random, choice);
    }label_9: ;
    
                {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public Sequence RewriteSequenceStrictOr() {
        Sequence seq, seq2;
        bool random = false, choice = false;
    seq = RewriteSequenceStrictXor();
    while (true) {
      if (mcc_2_18(3)) {
        ;
      } else {
        goto label_10;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOLLAR:
        mcc_consume_token(DOLLAR);
                       random = true;
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
                                               choice = true;
          break;
        default:
          mcc_la1[30] = mcc_gen;
          ;
          break;
        }
        break;
      default:
        mcc_la1[31] = mcc_gen;
        ;
        break;
      }
      mcc_consume_token(PIPE);
      seq2 = RewriteSequenceStrictXor();
                        seq = new SequenceStrictOr(seq, seq2, random, choice);
    }label_10: ;
    
                {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public Sequence RewriteSequenceStrictXor() {
        Sequence seq, seq2;
        bool random = false, choice = false;
    seq = RewriteSequenceStrictAnd();
    while (true) {
      if (mcc_2_19(3)) {
        ;
      } else {
        goto label_11;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOLLAR:
        mcc_consume_token(DOLLAR);
                       random = true;
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
                                               choice = true;
          break;
        default:
          mcc_la1[32] = mcc_gen;
          ;
          break;
        }
        break;
      default:
        mcc_la1[33] = mcc_gen;
        ;
        break;
      }
      mcc_consume_token(CIRCUMFLEX);
      seq2 = RewriteSequenceStrictAnd();
                        seq = new SequenceXor(seq, seq2, random, choice);
    }label_11: ;
    
                {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public Sequence RewriteSequenceStrictAnd() {
        Sequence seq, seq2;
        bool random = false, choice = false;
    seq = RewriteSequenceNeg();
    while (true) {
      if (mcc_2_20(3)) {
        ;
      } else {
        goto label_12;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOLLAR:
        mcc_consume_token(DOLLAR);
                       random = true;
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
                                               choice = true;
          break;
        default:
          mcc_la1[34] = mcc_gen;
          ;
          break;
        }
        break;
      default:
        mcc_la1[35] = mcc_gen;
        ;
        break;
      }
      mcc_consume_token(AMPERSAND);
      seq2 = RewriteSequenceNeg();
                        seq = new SequenceStrictAnd(seq, seq2, random, choice);
    }label_12: ;
    
                {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public Sequence RewriteSequenceNeg() {
        Sequence seq;
        SequenceVariable toVar;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case EXCLAMATIONMARK:
      mcc_consume_token(EXCLAMATIONMARK);
      seq = RewriteSequenceIteration();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case ASSIGN_TO:
        mcc_consume_token(ASSIGN_TO);
        toVar = Variable();
                                          {return new SequenceAssignSequenceResultToVar(toVar, new SequenceNot(seq));}
        break;
      case BOR_TO:
        mcc_consume_token(BOR_TO);
        toVar = Variable();
                                          {return new SequenceOrAssignSequenceResultToVar(toVar, new SequenceNot(seq));}
        break;
      case BAND_TO:
        mcc_consume_token(BAND_TO);
        toVar = Variable();
                                          {return new SequenceAndAssignSequenceResultToVar(toVar, new SequenceNot(seq));}
        break;
      default:
        mcc_la1[36] = mcc_gen;
                    {return new SequenceNot(seq);}
        break;
      }
      break;
    case DOLLAR:
    case DIV:
    case LPARENTHESIS:
    case LBOXBRACKET:
    case LANGLE:
    case LLANGLE:
    case LBRACE:
    case DOUBLECOLON:
    case PERCENT:
    case QUESTIONMARK:
    case TRUE:
    case FALSE:
    case FOR:
    case IF:
    case YIELD:
    case WORD:
      seq = RewriteSequenceIteration();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case ASSIGN_TO:
        mcc_consume_token(ASSIGN_TO);
        toVar = Variable();
                                          {return new SequenceAssignSequenceResultToVar(toVar, seq);}
        break;
      case BOR_TO:
        mcc_consume_token(BOR_TO);
        toVar = Variable();
                                          {return new SequenceOrAssignSequenceResultToVar(toVar, seq);}
        break;
      case BAND_TO:
        mcc_consume_token(BAND_TO);
        toVar = Variable();
                                          {return new SequenceAndAssignSequenceResultToVar(toVar, seq);}
        break;
      default:
        mcc_la1[37] = mcc_gen;
                    {return seq;}
        break;
      }
      break;
    default:
      mcc_la1[38] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public Sequence RewriteSequenceIteration() {
        Sequence seq;
        int minnum, maxnum = -1;
        bool maxspecified = false;
        bool maxstar = false;
    seq = SimpleSequence();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case STAR:
    case PLUS:
    case LBOXBRACKET:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case STAR:
        mcc_consume_token(STAR);
                                seq = new SequenceIterationMin(seq, 0);
        break;
      case PLUS:
        mcc_consume_token(PLUS);
                                seq = new SequenceIterationMin(seq, 1);
        break;
      case LBOXBRACKET:
        mcc_consume_token(LBOXBRACKET);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case NUMBER:
        case HEXNUMBER:
          minnum = Number();
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case COLON:
            mcc_consume_token(COLON);
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case NUMBER:
            case HEXNUMBER:
              maxnum = Number();
                                                                          maxspecified = true;
              break;
            case STAR:
              mcc_consume_token(STAR);
                                                              maxstar = true;
              break;
            default:
              mcc_la1[39] = mcc_gen;
              mcc_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            mcc_la1[40] = mcc_gen;
            ;
            break;
          }
          break;
        case STAR:
          mcc_consume_token(STAR);
                                              minnum = 0; maxstar = true;
          break;
        case PLUS:
          mcc_consume_token(PLUS);
                                              minnum = 1; maxstar = true;
          break;
        default:
          mcc_la1[41] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
        mcc_consume_token(RBOXBRACKET);
                            if(maxstar) {
                                        seq = new SequenceIterationMin(seq, minnum);
                            } else {
                                        if(!maxspecified) maxnum = minnum;
                                        seq = new SequenceIterationMinMax(seq, minnum, maxnum);
                                }
        break;
      default:
        mcc_la1[42] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      mcc_la1[43] = mcc_gen;
      ;
      break;
    }
                {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public Sequence SimpleSequence() {
        bool special = false, choice = false, chooseRandSpecified = false;
        Sequence seq, seq2, seq3 = null;
        List<SequenceVariable> variableList1 = new List<SequenceVariable>();
        List<SequenceVariable> variableList2 = new List<SequenceVariable>();
        List<Sequence> sequences = new List<Sequence>();
        SequenceVariable toVar, fromVar, fromVar2 = null, fromVar3 = null;
        SequenceExpression expr;
        SequenceComputation comp;
        int num = 0;
        String str;
        object constant;
    if (mcc_2_25(2147483647)) {
      toVar = Variable();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case EQUAL:
        mcc_consume_token(EQUAL);
        break;
      case GREATEREQUAL:
        mcc_consume_token(GREATEREQUAL);
        break;
      default:
        mcc_la1[44] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      if (mcc_2_21(2147483647)) {
        Word();
        mcc_consume_token(LPARENTHESIS);
                        {throw new ParseException("the destination variable(s) of a rule result assignment must be enclosed in parenthesis");}
      } else if (mcc_2_22(2147483647)) {
        constant = Constant();
                        {return new SequenceAssignConstToVar(toVar, constant);} // needed as sequence to allow variable declaration and initialization in sequence scope

      } else {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOUBLECOLON:
        case WORD:
          fromVar = Variable();
                        {return new SequenceAssignVarToVar(toVar, fromVar);} // needed as sequence to allow variable declaration and initialization in sequence scope

          break;
        default:
          mcc_la1[46] = mcc_gen;
          if (mcc_2_23(4)) {
            mcc_consume_token(DOLLAR);
            mcc_consume_token(PERCENT);
            mcc_consume_token(LPARENTHESIS);
            str = Text();
            mcc_consume_token(RPARENTHESIS);
            {return new SequenceAssignUserInputToVar(toVar, str);}
          } else {
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case DOLLAR:
              mcc_consume_token(DOLLAR);
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case PERCENT:
                mcc_consume_token(PERCENT);
                   choice = true;
                break;
              default:
                mcc_la1[45] = mcc_gen;
                ;
                break;
              }
              mcc_consume_token(LPARENTHESIS);
              num = Number();
              mcc_consume_token(RPARENTHESIS);
            {return new SequenceAssignRandomToVar(toVar, num, choice);}
              break;
            case LPARENTHESIS:
              mcc_consume_token(LPARENTHESIS);
              seq = RewriteSequence();
              mcc_consume_token(RPARENTHESIS);
                        {return new SequenceAssignSequenceResultToVar(toVar, seq);}
              break;
            default:
              mcc_la1[47] = mcc_gen;
              mcc_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        }
      }
    } else if (mcc_2_26(2147483647)) {
      toVar = VariableDefinition();
                {return new SequenceDeclareVariable(toVar);}
    } else {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case YIELD:
        mcc_consume_token(YIELD);
        toVar = VariableUse();
        mcc_consume_token(EQUAL);
        if (mcc_2_24(2)) {
          constant = Constant();
                        {return new SequenceBooleanComputation(new SequenceComputationAssignment(new AssignmentTargetYieldingVar(toVar), new SequenceExpressionConstant(constant)), null, false);}
        } else {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case DOUBLECOLON:
          case WORD:
            fromVar = Variable();
                        {return new SequenceBooleanComputation(new SequenceComputationAssignment(new AssignmentTargetYieldingVar(toVar), new SequenceExpressionVariable(fromVar)), null, false);}
            break;
          default:
            mcc_la1[48] = mcc_gen;
            mcc_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        mcc_la1[67] = mcc_gen;
        if (mcc_2_27(2)) {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case PERCENT:
            mcc_consume_token(PERCENT);
                        special = true;
            break;
          default:
            mcc_la1[49] = mcc_gen;
            ;
            break;
          }
          mcc_consume_token(TRUE);
        {return new SequenceBooleanComputation(new SequenceExpressionConstant(true), null, special);}
        } else if (mcc_2_28(2)) {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case PERCENT:
            mcc_consume_token(PERCENT);
                        special = true;
            break;
          default:
            mcc_la1[50] = mcc_gen;
            ;
            break;
          }
          mcc_consume_token(FALSE);
        {return new SequenceBooleanComputation(new SequenceExpressionConstant(false), null, special);}
        } else if (mcc_2_29(2147483647)) {
          seq = Rule();
                {return seq;}
        } else {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case DOUBLECOLON:
            mcc_consume_token(DOUBLECOLON);
            str = Word();
                fromVar = varDecls.LookupDefineGlobal(str);
                {return new SequenceBooleanComputation(new SequenceExpressionVariable(fromVar), null, false);}
            break;
          default:
            mcc_la1[68] = mcc_gen;
            if (mcc_2_30(3)) {
              mcc_consume_token(DOLLAR);
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case PERCENT:
                mcc_consume_token(PERCENT);
                   choice = true;
                break;
              default:
                mcc_la1[51] = mcc_gen;
                ;
                break;
              }
              mcc_consume_token(DOUBLEPIPE);
              mcc_consume_token(LPARENTHESIS);
              seq = RewriteSequence();
                                                 sequences.Add(seq);
              while (true) {
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case COMMA:
                  ;
                  break;
                default:
                  mcc_la1[52] = mcc_gen;
                  goto label_13;
                }
                mcc_consume_token(COMMA);
                seq = RewriteSequence();
                                                                                                    sequences.Add(seq);
              }label_13: ;
              
              mcc_consume_token(RPARENTHESIS);
                {return new SequenceLazyOrAll(sequences, choice);}
            } else if (mcc_2_31(3)) {
              mcc_consume_token(DOLLAR);
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case PERCENT:
                mcc_consume_token(PERCENT);
                   choice = true;
                break;
              default:
                mcc_la1[53] = mcc_gen;
                ;
                break;
              }
              mcc_consume_token(DOUBLEAMPERSAND);
              mcc_consume_token(LPARENTHESIS);
              seq = RewriteSequence();
                                                 sequences.Add(seq);
              while (true) {
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case COMMA:
                  ;
                  break;
                default:
                  mcc_la1[54] = mcc_gen;
                  goto label_14;
                }
                mcc_consume_token(COMMA);
                seq = RewriteSequence();
                                                                                                    sequences.Add(seq);
              }label_14: ;
              
              mcc_consume_token(RPARENTHESIS);
                {return new SequenceLazyAndAll(sequences, choice);}
            } else if (mcc_2_32(3)) {
              mcc_consume_token(DOLLAR);
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case PERCENT:
                mcc_consume_token(PERCENT);
                   choice = true;
                break;
              default:
                mcc_la1[55] = mcc_gen;
                ;
                break;
              }
              mcc_consume_token(PIPE);
              mcc_consume_token(LPARENTHESIS);
              seq = RewriteSequence();
                                                sequences.Add(seq);
              while (true) {
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case COMMA:
                  ;
                  break;
                default:
                  mcc_la1[56] = mcc_gen;
                  goto label_15;
                }
                mcc_consume_token(COMMA);
                seq = RewriteSequence();
                                                                                                   sequences.Add(seq);
              }label_15: ;
              
              mcc_consume_token(RPARENTHESIS);
                {return new SequenceStrictOrAll(sequences, choice);}
            } else if (mcc_2_33(3)) {
              mcc_consume_token(DOLLAR);
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case PERCENT:
                mcc_consume_token(PERCENT);
                   choice = true;
                break;
              default:
                mcc_la1[57] = mcc_gen;
                ;
                break;
              }
              mcc_consume_token(AMPERSAND);
              mcc_consume_token(LPARENTHESIS);
              seq = RewriteSequence();
                                                sequences.Add(seq);
              while (true) {
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case COMMA:
                  ;
                  break;
                default:
                  mcc_la1[58] = mcc_gen;
                  goto label_16;
                }
                mcc_consume_token(COMMA);
                seq = RewriteSequence();
                                                                                                   sequences.Add(seq);
              }label_16: ;
              
              mcc_consume_token(RPARENTHESIS);
                {return new SequenceStrictAndAll(sequences, choice);}
            } else if (mcc_2_34(3)) {
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case DOLLAR:
                mcc_consume_token(DOLLAR);
                chooseRandSpecified=true;
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case PERCENT:
                  mcc_consume_token(PERCENT);
                                                   choice = true;
                  break;
                default:
                  mcc_la1[59] = mcc_gen;
                  ;
                  break;
                }
                break;
              default:
                mcc_la1[60] = mcc_gen;
                ;
                break;
              }
              mcc_consume_token(LBRACE);
              mcc_consume_token(LPARENTHESIS);
              seq = Rule();
                                     sequences.Add(seq);
              while (true) {
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case COMMA:
                  ;
                  break;
                default:
                  mcc_la1[61] = mcc_gen;
                  goto label_17;
                }
                mcc_consume_token(COMMA);
                seq = Rule();
                                                                             sequences.Add(seq);
              }label_17: ;
              
              mcc_consume_token(RPARENTHESIS);
              mcc_consume_token(RBRACE);
                {return new SequenceSomeFromSet(sequences, chooseRandSpecified, choice);}
            } else {
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case LPARENTHESIS:
                mcc_consume_token(LPARENTHESIS);
                seq = RewriteSequence();
                mcc_consume_token(RPARENTHESIS);
                {return seq;}
                break;
              case LANGLE:
                mcc_consume_token(LANGLE);
                seq = RewriteSequence();
                mcc_consume_token(RANGLE);
        {return new SequenceTransaction(seq);}
                break;
              case LLANGLE:
                mcc_consume_token(LLANGLE);
                seq = Rule();
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case DOUBLESEMI:
                  mcc_consume_token(DOUBLESEMI);
                  break;
                case SEMI:
                  mcc_consume_token(SEMI);
                  break;
                default:
                  mcc_la1[62] = mcc_gen;
                  mcc_consume_token(-1);
                  throw new ParseException();
                }
                seq2 = RewriteSequence();
                mcc_consume_token(RRANGLE);
        {return new SequenceBacktrack(seq, seq2);}
                break;
              case DIV:
                mcc_consume_token(DIV);
                seq = RewriteSequence();
                mcc_consume_token(DIV);
        {return new SequencePause(seq);}
                break;
              case IF:
                mcc_consume_token(IF);
                mcc_consume_token(LBRACE);
               varDecls.PushScope(ScopeType.If);
                seq = RewriteSequence();
                mcc_consume_token(SEMI);
                  varDecls.PushScope(ScopeType.IfThenPart);
                seq2 = RewriteSequence();
                                                                                       varDecls.PopScope(variableList2);
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case SEMI:
                  mcc_consume_token(SEMI);
                  seq3 = RewriteSequence();
                  break;
                default:
                  mcc_la1[63] = mcc_gen;
                  ;
                  break;
                }
                                                varDecls.PopScope(variableList1);
                mcc_consume_token(RBRACE);
                if(seq3==null) {return new SequenceIfThen(seq, seq2, variableList1, variableList2);}
        else {return new SequenceIfThenElse(seq, seq2, seq3, variableList1, variableList2);}
                break;
              case FOR:
                mcc_consume_token(FOR);
                mcc_consume_token(LBRACE);
                    varDecls.PushScope(ScopeType.For);
                fromVar = Variable();
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case ARROW:
                case IN:
                  switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                  case ARROW:
                    mcc_consume_token(ARROW);
                    fromVar2 = Variable();
                    break;
                  default:
                    mcc_la1[64] = mcc_gen;
                    ;
                    break;
                  }
                  mcc_consume_token(IN);
                  fromVar3 = VariableUse();
                  break;
                default:
                  mcc_la1[65] = mcc_gen;
                  ;
                  break;
                }
                mcc_consume_token(SEMI);
                seq = RewriteSequence();
                                        varDecls.PopScope(variableList1);
                mcc_consume_token(RBRACE);
        {return new SequenceFor(fromVar, fromVar2, fromVar3, seq, variableList1);}
                break;
              case LBRACE:
              case PERCENT:
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case PERCENT:
                  mcc_consume_token(PERCENT);
               special = true;
                  break;
                default:
                  mcc_la1[66] = mcc_gen;
                  ;
                  break;
                }
                mcc_consume_token(LBRACE);
                                         varDecls.PushScope(ScopeType.Computation);
                comp = CompoundComputation();
                                                                                                                   varDecls.PopScope(variableList1);
                mcc_consume_token(RBRACE);
                {return new SequenceBooleanComputation(comp, variableList1, special);}
                break;
              default:
                mcc_la1[69] = mcc_gen;
                mcc_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
          }
        }
        break;
      }
    }
    throw new Exception("Missing return statement in function");
  }

  public SequenceComputation CompoundComputation() {
        SequenceComputation comp, compRight;
    comp = Computation();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case SEMI:
      mcc_consume_token(SEMI);
      compRight = CompoundComputation();
                                                                  {return new SequenceComputationThen(comp, compRight);}
      break;
    default:
      mcc_la1[70] = mcc_gen;
                                                                                                                             {return comp;}
      break;
    }
    throw new Exception("Missing return statement in function");
  }

  public SequenceComputation Computation() {
        SequenceVariable toVar;
        SequenceExpression expr;
        SequenceComputation comp, assignOrExpr;
        AssignmentTarget tgt;
        String procedure;
    if (mcc_2_35(2147483647)) {
      toVar = VariableDefinition();
      mcc_consume_token(GREATEREQUAL);
      assignOrExpr = ExpressionOrAssignment();
                {return new SequenceComputationAssignment(new AssignmentTargetVar(toVar), assignOrExpr);}
    } else if (mcc_2_36(2147483647)) {
      tgt = AssignmentTarget();
      mcc_consume_token(EQUAL);
      assignOrExpr = ExpressionOrAssignment();
                {return new SequenceComputationAssignment(tgt, assignOrExpr);}
    } else if (mcc_2_37(2147483647)) {
      toVar = VariableDefinition();
                {return new SequenceComputationVariableDeclaration(toVar);}
    } else if (mcc_2_38(2147483647)) {
      comp = MethodCallRepeated();
                {return comp;}
    } else if (GetToken(1).kind==WORD && GetToken(2).kind==LPARENTHESIS
                                    && (GetToken(1).image=="vfree" || GetToken(1).image=="vreset"
                                            || GetToken(1).image=="emit" || GetToken(1).image=="record"
                                            || GetToken(1).image=="rem" || GetToken(1).image=="clear")) {
      comp = ProcedureCall();
                {return comp;}
    } else if (mcc_2_39(1)) {
      expr = Expression();
                {return expr;}
    } else {
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public AssignmentTarget AssignmentTarget() {
        SequenceVariable toVar;
        SequenceExpression fromExpr;
        String attrName;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case YIELD:
      mcc_consume_token(YIELD);
      toVar = VariableUse();
                {return new AssignmentTargetYieldingVar(toVar);}
      break;
    default:
      mcc_la1[71] = mcc_gen;
      if (mcc_2_40(2147483647)) {
        toVar = VariableUse();
        mcc_consume_token(DOT);
        mcc_consume_token(VISITED);
        mcc_consume_token(LBOXBRACKET);
        fromExpr = Expression();
        mcc_consume_token(RBOXBRACKET);
                {return new AssignmentTargetVisited(toVar, fromExpr);}
      } else if (mcc_2_41(2147483647)) {
        toVar = VariableUse();
        mcc_consume_token(DOT);
        attrName = Word();
        {return new AssignmentTargetAttribute(toVar, attrName);}
      } else if (mcc_2_42(2147483647)) {
        toVar = VariableUse();
        mcc_consume_token(LBOXBRACKET);
        fromExpr = Expression();
        mcc_consume_token(RBOXBRACKET);
                {return new AssignmentTargetIndexedVar(toVar, fromExpr);}
      } else {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOUBLECOLON:
        case WORD:
          toVar = Variable();
                {return new AssignmentTargetVar(toVar);}
          break;
        default:
          mcc_la1[72] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    }
    throw new Exception("Missing return statement in function");
  }

  public SequenceComputation ExpressionOrAssignment() {
        SequenceExpression expr;
        SequenceComputation assignOrExpr;
        AssignmentTarget tgt;
        SequenceVariable toVar;
        String function;
    if (mcc_2_43(2147483647)) {
      toVar = VariableDefinition();
      mcc_consume_token(GREATEREQUAL);
      assignOrExpr = ExpressionOrAssignment();
                        {return new SequenceComputationAssignment(new AssignmentTargetVar(toVar), assignOrExpr);}
    } else if (mcc_2_44(2147483647)) {
      tgt = AssignmentTarget();
      mcc_consume_token(EQUAL);
      assignOrExpr = ExpressionOrAssignment();
                        {return new SequenceComputationAssignment(tgt, assignOrExpr);}
    } else if (mcc_2_45(1)) {
      expr = Expression();
                        {return expr;}
    } else {
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression Expression() {
        SequenceExpression seq, seq2, seq3;
    seq = ExpressionLazyOr();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case QUESTIONMARK:
      mcc_consume_token(QUESTIONMARK);
      seq2 = Expression();
      mcc_consume_token(COLON);
      seq3 = Expression();
                                                                               seq = new SequenceExpressionConditional(seq, seq2, seq3);
      break;
    default:
      mcc_la1[73] = mcc_gen;
      ;
      break;
    }
                                                                                                                                                {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionLazyOr() {
        SequenceExpression seq, seq2;
    seq = ExpressionLazyAnd();
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEPIPE:
        ;
        break;
      default:
        mcc_la1[74] = mcc_gen;
        goto label_18;
      }
      mcc_consume_token(DOUBLEPIPE);
      seq2 = ExpressionLazyAnd();
                                                                  seq = new SequenceExpressionLazyOr(seq, seq2);
    }label_18: ;
    
                                                                                                                        {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionLazyAnd() {
        SequenceExpression seq, seq2;
    seq = ExpressionStrictOr();
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEAMPERSAND:
        ;
        break;
      default:
        mcc_la1[75] = mcc_gen;
        goto label_19;
      }
      mcc_consume_token(DOUBLEAMPERSAND);
      seq2 = ExpressionStrictOr();
                                                                    seq = new SequenceExpressionLazyAnd(seq, seq2);
    }label_19: ;
    
                                                                                                                           {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionStrictOr() {
        SequenceExpression seq, seq2;
    seq = ExpressionStrictXor();
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case PIPE:
        ;
        break;
      default:
        mcc_la1[76] = mcc_gen;
        goto label_20;
      }
      mcc_consume_token(PIPE);
      seq2 = ExpressionStrictXor();
                                                                     seq = new SequenceExpressionStrictOr(seq, seq2);
    }label_20: ;
    
                                                                                                                             {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionStrictXor() {
        SequenceExpression seq, seq2;
    seq = ExpressionStrictAnd();
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case CIRCUMFLEX:
        ;
        break;
      default:
        mcc_la1[77] = mcc_gen;
        goto label_21;
      }
      mcc_consume_token(CIRCUMFLEX);
      seq2 = ExpressionStrictAnd();
                                                                     seq = new SequenceExpressionStrictXor(seq, seq2);
    }label_21: ;
    
                                                                                                                              {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionStrictAnd() {
        SequenceExpression seq, seq2;
    seq = ExpressionEquality();
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case AMPERSAND:
        ;
        break;
      default:
        mcc_la1[78] = mcc_gen;
        goto label_22;
      }
      mcc_consume_token(AMPERSAND);
      seq2 = ExpressionEquality();
                                                                   seq = new SequenceExpressionStrictAnd(seq, seq2);
    }label_22: ;
    
                                                                                                                            {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionEquality() {
        SequenceExpression seq, seq2;
    seq = ExpressionRelation();
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case EQUALITY:
      case INEQUALITY:
      case STRUCTURALEQUAL:
        ;
        break;
      default:
        mcc_la1[79] = mcc_gen;
        goto label_23;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case EQUALITY:
        mcc_consume_token(EQUALITY);
        seq2 = ExpressionRelation();
                                                                    seq = new SequenceExpressionEqual(seq, seq2);
        break;
      case INEQUALITY:
        mcc_consume_token(INEQUALITY);
        seq2 = ExpressionRelation();
                                                                                            seq = new SequenceExpressionNotEqual(seq, seq2);
        break;
      case STRUCTURALEQUAL:
        mcc_consume_token(STRUCTURALEQUAL);
        seq2 = ExpressionRelation();
                                                                                            seq = new SequenceExpressionStructuralEqual(seq, seq2);
        break;
      default:
        mcc_la1[80] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    }label_23: ;
    
          {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionRelation() {
        SequenceExpression seq, seq2;
    seq = ExpressionAdd();
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case LOWEREQUAL:
      case GREATEREQUAL:
      case LANGLE:
      case RANGLE:
      case IN:
        ;
        break;
      default:
        mcc_la1[81] = mcc_gen;
        goto label_24;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case LANGLE:
        mcc_consume_token(LANGLE);
        seq2 = ExpressionAdd();
                                                         seq = new SequenceExpressionLower(seq, seq2);
        break;
      case RANGLE:
        mcc_consume_token(RANGLE);
        seq2 = ExpressionAdd();
                                                                             seq = new SequenceExpressionGreater(seq, seq2);
        break;
      case LOWEREQUAL:
        mcc_consume_token(LOWEREQUAL);
        seq2 = ExpressionAdd();
                                                                              seq = new SequenceExpressionLowerEqual(seq, seq2);
        break;
      case GREATEREQUAL:
        mcc_consume_token(GREATEREQUAL);
        seq2 = ExpressionAdd();
                                                                              seq = new SequenceExpressionGreaterEqual(seq, seq2);
        break;
      case IN:
        mcc_consume_token(IN);
        seq2 = ExpressionAdd();
                                                                              seq = new SequenceExpressionInContainer(seq, seq2);
        break;
      default:
        mcc_la1[82] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    }label_24: ;
    
          {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionAdd() {
        SequenceExpression seq, seq2;
    seq = ExpressionNot();
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case PLUS:
        ;
        break;
      default:
        mcc_la1[83] = mcc_gen;
        goto label_25;
      }
      mcc_consume_token(PLUS);
      seq2 = ExpressionNot();
                                                         seq = new SequenceExpressionPlus(seq, seq2);
    }label_25: ;
    
                                                                                                             {return seq;}
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionNot() {
        SequenceExpression seq;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case EXCLAMATIONMARK:
      mcc_consume_token(EXCLAMATIONMARK);
      seq = ExpressionBasic();
                                {return new SequenceExpressionNot(seq);}
      break;
    default:
      mcc_la1[84] = mcc_gen;
      if (mcc_2_46(1)) {
        seq = ExpressionBasic();
                                  {return seq;}
      } else {
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    }
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression ExpressionBasic() {
        List<SequenceVariable> variableList1 = new List<SequenceVariable>();
        List<SequenceExpression> argExprs = new List<SequenceExpression>();
        SequenceVariable fromVar;
        String attrName, method, elemName;
        SequenceExpression expr;
        SequenceComputation comp;
        object constant;
    if (mcc_2_47(2147483647)) {
      comp = MethodCall();
                if(comp is SequenceExpression)
                        {return (SequenceExpression)comp;}
                else
                        {throw new ParseException("expression method call expected, not the compution method call with side effects: "+comp.Symbol);}
    } else if (mcc_2_48(2147483647)) {
      fromVar = VariableUse();
      mcc_consume_token(DOT);
      mcc_consume_token(VISITED);
      mcc_consume_token(LBOXBRACKET);
      expr = Expression();
      mcc_consume_token(RBOXBRACKET);
                {return new SequenceExpressionIsVisited(fromVar, expr);}
    } else if (mcc_2_49(2147483647)) {
      fromVar = VariableUse();
      mcc_consume_token(DOT);
      attrName = Word();
                {return new SequenceExpressionAttribute(fromVar, attrName);}
    } else if (mcc_2_50(2147483647)) {
      fromVar = VariableUse();
      mcc_consume_token(LBOXBRACKET);
      expr = Expression();
      mcc_consume_token(RBOXBRACKET);
                {return new SequenceExpressionContainerAccess(fromVar, expr);}
    } else if (mcc_2_51(2147483647)) {
      expr = FunctionCall();
                {return expr;}
    } else if (mcc_2_52(2)) {
      constant = Constant();
                {return new SequenceExpressionConstant(constant);}
    } else {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DEF:
        mcc_consume_token(DEF);
        mcc_consume_token(LPARENTHESIS);
        Arguments(argExprs);
        mcc_consume_token(RPARENTHESIS);
                {return new SequenceExpressionDef(argExprs.ToArray());}
        break;
      case DOUBLECOLON:
      case WORD:
        fromVar = VariableUse();
                {return new SequenceExpressionVariable(fromVar);}
        break;
      case AT:
        mcc_consume_token(AT);
        mcc_consume_token(LPARENTHESIS);
        elemName = Text();
        mcc_consume_token(RPARENTHESIS);
                {return new SequenceExpressionElementFromGraph(elemName);}
        break;
      case LPARENTHESIS:
        mcc_consume_token(LPARENTHESIS);
        expr = Expression();
        mcc_consume_token(RPARENTHESIS);
                {return expr;}
        break;
      default:
        mcc_la1[85] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Exception("Missing return statement in function");
  }

  public SequenceComputation ProcedureCall() {
        String procedure;
        SequenceExpression fromExpr = null;
    procedure = Word();
    mcc_consume_token(LPARENTHESIS);
    if (mcc_2_53(1)) {
      fromExpr = Expression();
    } else {
      ;
    }
    mcc_consume_token(RPARENTHESIS);
                if(procedure=="vfree") {
                        if(fromExpr==null) {throw new ParseException("\"" + procedure + "\" expects 1 parameter)");}
                        {return new SequenceComputationVFree(fromExpr);}
                } else if(procedure=="vreset") {
                        if(fromExpr==null) {throw new ParseException("\"" + procedure + "\" expects 1 parameter)");}
                        {return new SequenceComputationVReset(fromExpr);}
                } else if(procedure=="emit") {
                        if(fromExpr==null) {throw new ParseException("\"" + procedure + "\" expects 1 parameter)");}
                        {return new SequenceComputationEmit(fromExpr);}
                } else if(procedure=="record") {
                        if(fromExpr==null) {throw new ParseException("\"" + procedure + "\" expects 1 parameter)");}
                        {return new SequenceComputationRecord(fromExpr);}
                } else if(procedure=="rem") {
                        if(fromExpr==null) {throw new ParseException("\"" + procedure + "\" expects 1 parameter)");}
                        {return new SequenceComputationGraphRem(fromExpr);}
                } else if(procedure=="clear") {
                        if(fromExpr!=null) {throw new ParseException("\"" + procedure + "\" expects no parameters)");}
                        {return new SequenceComputationGraphClear();}
                } else {
                        {throw new ParseException("Unknown procedure name: \"" + procedure + "\"! (available are vfree|vreset|emit|record|rem|clear)");}
                }
    throw new Exception("Missing return statement in function");
  }

  public SequenceExpression FunctionCall() {
        String function;
        SequenceExpression fromExpr = null, fromExpr2 = null, fromExpr3 = null;
    function = Word();
    mcc_consume_token(LPARENTHESIS);
    if (mcc_2_54(1)) {
      fromExpr = Expression();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case COMMA:
        mcc_consume_token(COMMA);
        fromExpr2 = Expression();
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          mcc_consume_token(COMMA);
          fromExpr3 = Expression();
          break;
        default:
          mcc_la1[86] = mcc_gen;
          ;
          break;
        }
        break;
      default:
        mcc_la1[87] = mcc_gen;
        ;
        break;
      }
    } else {
      ;
    }
    mcc_consume_token(RPARENTHESIS);
                if(function=="valloc") {
                        if(fromExpr!=null || fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + function + "\" expects no parameters)");}
                        {return new SequenceExpressionVAlloc();}
                } else if(function=="add") {
                        if(fromExpr==null || (fromExpr2!=null && fromExpr3==null)) {throw new ParseException("\"" + function + "\" expects 1(for a node) or 3(for an edge) parameters)");}
                        {return new SequenceExpressionGraphAdd(fromExpr, fromExpr2, fromExpr3);}
                } else if(function=="insertInduced") {
                        if(fromExpr==null || fromExpr2==null || fromExpr3!=null) {throw new ParseException("\"" + function + "\" expects 2 parameters (the set of nodes to compute the induced subgraph from which will be cloned and inserted, and one node of the set of which the clone will be returned)");}
                        {return new SequenceExpressionInsertInduced(fromExpr, fromExpr2);}
                } else if(function=="insertDefined") {
                        if(fromExpr==null || fromExpr2==null || fromExpr3!=null) {throw new ParseException("\"" + function + "\" expects 2 parameters (the set of edges which define the subgraph which will be cloned and inserted, and one edge of the set of which the clone will be returned)");}
                        {return new SequenceExpressionInsertDefined(fromExpr, fromExpr2);}
                } else if(function=="adjacent") {
                        if(fromExpr==null) {throw new ParseException("\"" + function + "\" expects 1 (start node only) or 2 (start node, incident edge type) or 3 (start node, incident edge type, adjacent node type) parameters)");}
                        {return new SequenceExpressionAdjacentIncident(fromExpr, fromExpr2, fromExpr3, SequenceExpressionType.AdjacentNodes);}
                } else if(function=="adjacentIncoming") {
                        if(fromExpr==null) {throw new ParseException("\"" + function + "\" expects 1 (start node only) or 2 (start node, incident edge type) or 3 (start node, incident edge type, adjacent node type) parameters)");}
                        {return new SequenceExpressionAdjacentIncident(fromExpr, fromExpr2, fromExpr3, SequenceExpressionType.AdjacentNodesViaIncoming);}
                } else if(function=="adjacentOutgoing") {
                        if(fromExpr==null) {throw new ParseException("\"" + function + "\" expects 1 (start node only) or 2 (start node, incident edge type) or 3 (start node, incident edge type, adjacent node type) parameters)");}
                        {return new SequenceExpressionAdjacentIncident(fromExpr, fromExpr2, fromExpr3, SequenceExpressionType.AdjacentNodesViaOutgoing);}
                } else if(function=="incident") {
                        if(fromExpr==null) {throw new ParseException("\"" + function + "\" expects 1 (start node only) or 2 (start node, incident edge type) or 3 (start node, incident edge type, adjacent node type) parameters)");}
                        {return new SequenceExpressionAdjacentIncident(fromExpr, fromExpr2, fromExpr3, SequenceExpressionType.IncidentEdges);}
                } else if(function=="incoming") {
                        if(fromExpr==null) {throw new ParseException("\"" + function + "\" expects 1 (start node only) or 2 (start node, incident edge type) or 3 (start node, incident edge type, adjacent node type) parameters)");}
                        {return new SequenceExpressionAdjacentIncident(fromExpr, fromExpr2, fromExpr3, SequenceExpressionType.IncomingEdges);}
                } else if(function=="outgoing") {
                        if(fromExpr==null) {throw new ParseException("\"" + function + "\" expects 1 (start node only) or 2 (start node, incident edge type) or 3 (start node, incident edge type, adjacent node type) parameters)");}
                        {return new SequenceExpressionAdjacentIncident(fromExpr, fromExpr2, fromExpr3, SequenceExpressionType.OutgoingEdges);}
                } else if(function=="inducedSubgraph") {
                        if(fromExpr==null || fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + function + "\" expects 1 parameter (the set of nodes to construct the induced subgraph from)");}
                        {return new SequenceExpressionInducedSubgraph(fromExpr);}
                } else if(function=="definedSubgraph") {
                        if(fromExpr==null || fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + function + "\" expects 1 parameter (the set of edges to construct the defined subgraph from)");}
                        {return new SequenceExpressionDefinedSubgraph(fromExpr);}
                } else if(function=="source") {
                        if(fromExpr==null || fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + function + "\" expects 1 parameter (the edge to get the source node from)");}
                        {return new SequenceExpressionSource(fromExpr);}
                } else if(function=="target") {
                        if(fromExpr==null || fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + function + "\" expects 1 parameter (the edge to get the target node from)");}
                        {return new SequenceExpressionTarget(fromExpr);}
                } else {
                        {throw new ParseException("Unknown function name: \"" + function + "\"! (available are valloc|add|insertInduced|insertDefined|adjacent|adjacentIncoming|adjacentOutgoing|incident|incoming|outgoing|inducedSubgraph|definedSubgraph|source|target)");}
                }
    throw new Exception("Missing return statement in function");
  }

  public SequenceComputation MethodCall() {
        String method;
        SequenceVariable fromVar;
        SequenceExpression fromExpr2 = null, fromExpr3 = null;
    fromVar = VariableUse();
    mcc_consume_token(DOT);
    method = Word();
    mcc_consume_token(LPARENTHESIS);
    if (mcc_2_55(1)) {
      fromExpr2 = Expression();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case COMMA:
        mcc_consume_token(COMMA);
        fromExpr3 = Expression();
        break;
      default:
        mcc_la1[88] = mcc_gen;
        ;
        break;
      }
    } else {
      ;
    }
    mcc_consume_token(RPARENTHESIS);
                if(method=="add") {
                        if(fromExpr2==null) {throw new ParseException("\"" + method + "\" expects 1(for set,array end) or 2(for map,array with index) parameters)");}
                        {return new SequenceComputationContainerAdd(fromVar, fromExpr2, fromExpr3);}
                } else if(method=="rem") {
                        if(fromExpr3!=null) {throw new ParseException("\"" + method + "\" expects 1(for set,map,array with index) or 0(for array end) parameters )");}
                        {return new SequenceComputationContainerRem(fromVar, fromExpr2);}
                } else if(method=="clear") {
                        if(fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + method + "\" expects no parameters)");}
                        {return new SequenceComputationContainerClear(fromVar);}
                } else if(method=="size") {
                        if(fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + method + "\" expects no parameters)");}
                        {return new SequenceExpressionContainerSize(fromVar);}
                } else if(method=="empty") {
                        if(fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + method + "\" expects no parameters)");}
                        {return new SequenceExpressionContainerEmpty(fromVar);}
                } else {
                        {throw new ParseException("Unknown method name: \"" + method + "\"! (available are add|rem|clear as sequences and size|empty as expressions on set/map/array)");}
                }
    throw new Exception("Missing return statement in function");
  }

  public SequenceComputation MethodCallRepeated() {
        String method;
        SequenceComputation methodCall;
        SequenceExpression fromExpr2 = null, fromExpr3 = null;
    methodCall = MethodCall();
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOT:
        ;
        break;
      default:
        mcc_la1[89] = mcc_gen;
        goto label_26;
      }
      mcc_consume_token(DOT);
      method = Word();
      mcc_consume_token(LPARENTHESIS);
      if (mcc_2_56(1)) {
        fromExpr2 = Expression();
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          mcc_consume_token(COMMA);
          fromExpr3 = Expression();
          break;
        default:
          mcc_la1[90] = mcc_gen;
          ;
          break;
        }
      } else {
        ;
      }
      mcc_consume_token(RPARENTHESIS);
                        if(method=="add") {
                                if(fromExpr2==null) {throw new ParseException("\"" + method + "\" expects 1(for set,array end) or 2(for map,array with index) parameters)");}
                                methodCall = new SequenceComputationContainerAdd(methodCall, fromExpr2, fromExpr3);
                                fromExpr2 = null; fromExpr3 = null;
                        } else if(method=="rem") {
                                if(fromExpr3!=null) {throw new ParseException("\"" + method + "\" expects 1(for set,map,array with index) or 0(for array end) parameters )");}
                                methodCall = new SequenceComputationContainerRem(methodCall, fromExpr2);
                                fromExpr2 = null;
                        } else if(method=="clear") {
                                if(fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + method + "\" expects no parameters)");}
                                methodCall = new SequenceComputationContainerClear(methodCall);
                        } else if(method=="size") {
                                if(fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + method + "\" expects no parameters)");}
                                methodCall = new SequenceExpressionContainerSize(methodCall);
                        } else if(method=="empty") {
                                if(fromExpr2!=null || fromExpr3!=null) {throw new ParseException("\"" + method + "\" expects no parameters)");}
                                methodCall = new SequenceExpressionContainerEmpty(methodCall);
                        } else {
                                {throw new ParseException("Unknown method name: \"" + method + "\"! (available are add|rem|clear as sequences and size|empty as expressions on set/map/array)");}
                        }
    }label_26: ;
    
          {return methodCall;}
    throw new Exception("Missing return statement in function");
  }

  public void RuleLookahead() {
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case LPARENTHESIS:
      mcc_consume_token(LPARENTHESIS);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case WORD:
        Word();
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COLON:
          mcc_consume_token(COLON);
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case WORD:
            Word();
            break;
          case SET:
            mcc_consume_token(SET);
            mcc_consume_token(LANGLE);
            Word();
            mcc_consume_token(RANGLE);
            break;
          case MAP:
            mcc_consume_token(MAP);
            mcc_consume_token(LANGLE);
            Word();
            mcc_consume_token(COMMA);
            Word();
            mcc_consume_token(RANGLE);
            break;
          case ARRAY:
            mcc_consume_token(ARRAY);
            mcc_consume_token(LANGLE);
            Word();
            mcc_consume_token(RANGLE);
            break;
          default:
            mcc_la1[91] = mcc_gen;
            mcc_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          mcc_la1[92] = mcc_gen;
          ;
          break;
        }
        break;
      case DOUBLECOLON:
        mcc_consume_token(DOUBLECOLON);
        Word();
        break;
      default:
        mcc_la1[93] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[94] = mcc_gen;
          goto label_27;
        }
        mcc_consume_token(COMMA);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case WORD:
          Word();
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case COLON:
            mcc_consume_token(COLON);
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case WORD:
              Word();
              break;
            case SET:
              mcc_consume_token(SET);
              mcc_consume_token(LANGLE);
              Word();
              mcc_consume_token(RANGLE);
              break;
            case MAP:
              mcc_consume_token(MAP);
              mcc_consume_token(LANGLE);
              Word();
              mcc_consume_token(COMMA);
              Word();
              mcc_consume_token(RANGLE);
              break;
            case ARRAY:
              mcc_consume_token(ARRAY);
              mcc_consume_token(LANGLE);
              Word();
              mcc_consume_token(RANGLE);
              break;
            default:
              mcc_la1[95] = mcc_gen;
              mcc_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            mcc_la1[96] = mcc_gen;
            ;
            break;
          }
          break;
        case DOUBLECOLON:
          mcc_consume_token(DOUBLECOLON);
          Word();
          break;
        default:
          mcc_la1[97] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
      }label_27: ;
      
      mcc_consume_token(RPARENTHESIS);
      mcc_consume_token(EQUAL);
      break;
    default:
      mcc_la1[98] = mcc_gen;
      ;
      break;
    }
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOLLAR:
    case LBOXBRACKET:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOLLAR:
        mcc_consume_token(DOLLAR);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
          break;
        default:
          mcc_la1[99] = mcc_gen;
          ;
          break;
        }
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOUBLECOLON:
        case WORD:
          Variable();
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case COMMA:
            mcc_consume_token(COMMA);
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case DOUBLECOLON:
            case WORD:
              Variable();
              break;
            case STAR:
              mcc_consume_token(STAR);
              break;
            default:
              mcc_la1[100] = mcc_gen;
              mcc_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            mcc_la1[101] = mcc_gen;
            ;
            break;
          }
          break;
        default:
          mcc_la1[102] = mcc_gen;
          ;
          break;
        }
        break;
      default:
        mcc_la1[103] = mcc_gen;
        ;
        break;
      }
      mcc_consume_token(LBOXBRACKET);
      break;
    case PERCENT:
    case QUESTIONMARK:
    case WORD:
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
        case QUESTIONMARK:
          ;
          break;
        default:
          mcc_la1[104] = mcc_gen;
          goto label_28;
        }
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
          break;
        case QUESTIONMARK:
          mcc_consume_token(QUESTIONMARK);
          break;
        default:
          mcc_la1[105] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
      }label_28: ;
      
      Word();
      break;
    default:
      mcc_la1[106] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public Sequence Rule() {
        bool special = false, test = false;
        String str;
        bool chooseRandSpecified = false, chooseRandSpecified2 = false, choice = false;
        SequenceVariable varChooseRand = null, varChooseRand2 = null;
        List<SequenceExpression> argExprs = new List<SequenceExpression>();
        List<SequenceVariable> returnVars = new List<SequenceVariable>();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case LPARENTHESIS:
      mcc_consume_token(LPARENTHESIS);
      VariableList(returnVars);
      mcc_consume_token(RPARENTHESIS);
      mcc_consume_token(EQUAL);
      break;
    default:
      mcc_la1[107] = mcc_gen;
      ;
      break;
    }
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOLLAR:
    case LBOXBRACKET:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOLLAR:
        mcc_consume_token(DOLLAR);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
                                   choice = true;
          break;
        default:
          mcc_la1[108] = mcc_gen;
          ;
          break;
        }
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOUBLECOLON:
        case WORD:
          varChooseRand = Variable();
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case COMMA:
            mcc_consume_token(COMMA);
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case DOUBLECOLON:
            case WORD:
              varChooseRand2 = Variable();
              break;
            case STAR:
              mcc_consume_token(STAR);
              break;
            default:
              mcc_la1[109] = mcc_gen;
              mcc_consume_token(-1);
              throw new ParseException();
            }
                                                                                                                          chooseRandSpecified2 = true;
            break;
          default:
            mcc_la1[110] = mcc_gen;
            ;
            break;
          }
          break;
        default:
          mcc_la1[111] = mcc_gen;
          ;
          break;
        }
                                                                                                                                                                chooseRandSpecified = true;
        break;
      default:
        mcc_la1[112] = mcc_gen;
        ;
        break;
      }
      mcc_consume_token(LBOXBRACKET);
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
        case QUESTIONMARK:
          ;
          break;
        default:
          mcc_la1[113] = mcc_gen;
          goto label_29;
        }
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
                           special = true;
          break;
        case QUESTIONMARK:
          mcc_consume_token(QUESTIONMARK);
                                                     test = true;
          break;
        default:
          mcc_la1[114] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
      }label_29: ;
      
      str = Word();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case LPARENTHESIS:
        mcc_consume_token(LPARENTHESIS);
        Arguments(argExprs);
        mcc_consume_token(RPARENTHESIS);
        break;
      default:
        mcc_la1[115] = mcc_gen;
        ;
        break;
      }
      mcc_consume_token(RBOXBRACKET);
                        // No variable with this name may exist
                        if(varDecls.Lookup(str)!=null)
                                {throw new SequenceParserException(str, SequenceParserError.RuleNameUsedByVariable);}

                        {return new SequenceRuleAllCall(CreateRuleInvocationParameterBindings(str, argExprs, returnVars),
                                        special, test, chooseRandSpecified, varChooseRand, chooseRandSpecified2, varChooseRand2, choice);}
      break;
    case PERCENT:
    case QUESTIONMARK:
    case WORD:
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
        case QUESTIONMARK:
          ;
          break;
        default:
          mcc_la1[116] = mcc_gen;
          goto label_30;
        }
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case PERCENT:
          mcc_consume_token(PERCENT);
                       special = true;
          break;
        case QUESTIONMARK:
          mcc_consume_token(QUESTIONMARK);
                                                 test = true;
          break;
        default:
          mcc_la1[117] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
      }label_30: ;
      
      str = Word();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case LPARENTHESIS:
        mcc_consume_token(LPARENTHESIS);
        Arguments(argExprs);
        mcc_consume_token(RPARENTHESIS);
        break;
      default:
        mcc_la1[118] = mcc_gen;
        ;
        break;
      }
                        if(argExprs.Count==0 && returnVars.Count==0)
                        {
                                SequenceVariable var = varDecls.Lookup(str);
                                if(var!=null)
                                {
                                        if(var.Type!="" && var.Type!="boolean")
                                                {throw new SequenceParserException(str, "untyped or bool", var.Type);}
                                        {return new SequenceBooleanComputation(new SequenceExpressionVariable(var), null, special);}
                                }
                        }

                        // No variable with this name may exist
                        if(varDecls.Lookup(str)!=null)
                                {throw new SequenceParserException(str, SequenceParserError.RuleNameUsedByVariable);}

                        if(IsSequenceName(str))
                                {return new SequenceSequenceCall(
                                                                CreateSequenceInvocationParameterBindings(str, argExprs, returnVars),
                                                                special);}
                        else
                                {return new SequenceRuleCall(
                                                                CreateRuleInvocationParameterBindings(str, argExprs, returnVars),
                                                                special, test);}
      break;
    default:
      mcc_la1[119] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  RuleInvocationParameterBindings CreateRuleInvocationParameterBindings(String ruleName,
                                List<SequenceExpression> argExprs, List<SequenceVariable> returnVars)  {
        IAction action = null;
        if(actions != null)
                action = actions.GetAction(ruleName);

        RuleInvocationParameterBindings paramBindings = new RuleInvocationParameterBindings(action,
                        argExprs.ToArray(), new object[argExprs.Count], returnVars.ToArray());

        if(action == null)
                paramBindings.Name = ruleName;

        return paramBindings;
  }

  SequenceInvocationParameterBindings CreateSequenceInvocationParameterBindings(String sequenceName,
                                List<SequenceExpression> argExprs, List<SequenceVariable> returnVars)  {
        SequenceDefinition sequenceDef = null;
        if(actions != null) {
                sequenceDef = actions.RetrieveGraphRewriteSequenceDefinition(sequenceName);
        }

        SequenceInvocationParameterBindings paramBindings = new SequenceInvocationParameterBindings(sequenceDef,
                        argExprs.ToArray(), new object[argExprs.Count], returnVars.ToArray());

        if(sequenceDef == null)
                paramBindings.Name = sequenceName;

        return paramBindings;
  }

  bool IsSequenceName(String ruleOrSequenceName)  {
        if(actions != null) {
                return actions.RetrieveGraphRewriteSequenceDefinition(ruleOrSequenceName) != null;
        } else {
                foreach(String sequenceName in sequenceNames)
                        if(ruleOrSequenceName == sequenceName)
                                return true;
                return false;
        }
  }

  String RemoveTypeSuffix(String value)  {
        if (value.EndsWith("y") || value.EndsWith("Y")
                || value.EndsWith("s") || value.EndsWith("S")
                || value.EndsWith("l") || value.EndsWith("L"))
                return value.Substring(0, value.Length - 1);
        else
                return value;
  }

  private bool mcc_2_1(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_1(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(0, xla); }
  }

  private bool mcc_2_2(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_2(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(1, xla); }
  }

  private bool mcc_2_3(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_3(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(2, xla); }
  }

  private bool mcc_2_4(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_4(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(3, xla); }
  }

  private bool mcc_2_5(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_5(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(4, xla); }
  }

  private bool mcc_2_6(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_6(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(5, xla); }
  }

  private bool mcc_2_7(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_7(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(6, xla); }
  }

  private bool mcc_2_8(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_8(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(7, xla); }
  }

  private bool mcc_2_9(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_9(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(8, xla); }
  }

  private bool mcc_2_10(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_10(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(9, xla); }
  }

  private bool mcc_2_11(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_11(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(10, xla); }
  }

  private bool mcc_2_12(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_12(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(11, xla); }
  }

  private bool mcc_2_13(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_13(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(12, xla); }
  }

  private bool mcc_2_14(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_14(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(13, xla); }
  }

  private bool mcc_2_15(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_15(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(14, xla); }
  }

  private bool mcc_2_16(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_16(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(15, xla); }
  }

  private bool mcc_2_17(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_17(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(16, xla); }
  }

  private bool mcc_2_18(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_18(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(17, xla); }
  }

  private bool mcc_2_19(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_19(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(18, xla); }
  }

  private bool mcc_2_20(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_20(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(19, xla); }
  }

  private bool mcc_2_21(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_21(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(20, xla); }
  }

  private bool mcc_2_22(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_22(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(21, xla); }
  }

  private bool mcc_2_23(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_23(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(22, xla); }
  }

  private bool mcc_2_24(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_24(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(23, xla); }
  }

  private bool mcc_2_25(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_25(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(24, xla); }
  }

  private bool mcc_2_26(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_26(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(25, xla); }
  }

  private bool mcc_2_27(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_27(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(26, xla); }
  }

  private bool mcc_2_28(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_28(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(27, xla); }
  }

  private bool mcc_2_29(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_29(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(28, xla); }
  }

  private bool mcc_2_30(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_30(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(29, xla); }
  }

  private bool mcc_2_31(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_31(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(30, xla); }
  }

  private bool mcc_2_32(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_32(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(31, xla); }
  }

  private bool mcc_2_33(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_33(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(32, xla); }
  }

  private bool mcc_2_34(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_34(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(33, xla); }
  }

  private bool mcc_2_35(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_35(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(34, xla); }
  }

  private bool mcc_2_36(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_36(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(35, xla); }
  }

  private bool mcc_2_37(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_37(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(36, xla); }
  }

  private bool mcc_2_38(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_38(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(37, xla); }
  }

  private bool mcc_2_39(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_39(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(38, xla); }
  }

  private bool mcc_2_40(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_40(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(39, xla); }
  }

  private bool mcc_2_41(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_41(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(40, xla); }
  }

  private bool mcc_2_42(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_42(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(41, xla); }
  }

  private bool mcc_2_43(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_43(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(42, xla); }
  }

  private bool mcc_2_44(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_44(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(43, xla); }
  }

  private bool mcc_2_45(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_45(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(44, xla); }
  }

  private bool mcc_2_46(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_46(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(45, xla); }
  }

  private bool mcc_2_47(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_47(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(46, xla); }
  }

  private bool mcc_2_48(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_48(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(47, xla); }
  }

  private bool mcc_2_49(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_49(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(48, xla); }
  }

  private bool mcc_2_50(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_50(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(49, xla); }
  }

  private bool mcc_2_51(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_51(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(50, xla); }
  }

  private bool mcc_2_52(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_52(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(51, xla); }
  }

  private bool mcc_2_53(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_53(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(52, xla); }
  }

  private bool mcc_2_54(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_54(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(53, xla); }
  }

  private bool mcc_2_55(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_55(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(54, xla); }
  }

  private bool mcc_2_56(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_56(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(55, xla); }
  }

  private bool mcc_3R_164() {
    if (mcc_3R_188()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_189()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_81() {
    if (mcc_3R_125()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_126()) {
    mcc_scanpos = xsp;
    if (mcc_3R_127()) {
    mcc_scanpos = xsp;
    if (mcc_3R_128()) {
    mcc_scanpos = xsp;
    if (mcc_3R_129()) return true;
    }
    }
    }
    return false;
  }

  private bool mcc_3_1() {
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(DOUBLECOLON)) return true;
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_71() {
    if (mcc_scan_token(NULL)) return true;
    return false;
  }

  private bool mcc_3R_185() {
    if (mcc_scan_token(ARRAY)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    return false;
  }

  private bool mcc_3R_70() {
    if (mcc_scan_token(FALSE)) return true;
    return false;
  }

  private bool mcc_3R_149() {
    if (mcc_3R_164()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_165()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_69() {
    if (mcc_scan_token(TRUE)) return true;
    return false;
  }

  private bool mcc_3R_78() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_68() {
    if (mcc_3R_123()) return true;
    return false;
  }

  private bool mcc_3R_45() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_80()) {
    mcc_scanpos = xsp;
    if (mcc_3R_81()) return true;
    }
    return false;
  }

  private bool mcc_3R_80() {
    if (mcc_scan_token(EXCLAMATIONMARK)) return true;
    if (mcc_3R_125()) return true;
    return false;
  }

  private bool mcc_3R_67() {
    if (mcc_3R_122()) return true;
    return false;
  }

  private bool mcc_3R_44() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_79()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_66() {
    if (mcc_3R_121()) return true;
    return false;
  }

  private bool mcc_3R_120() {
    if (mcc_scan_token(HEXNUMBER_LONG)) return true;
    return false;
  }

  private bool mcc_3_20() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_44()) mcc_scanpos = xsp;
    if (mcc_scan_token(AMPERSAND)) return true;
    if (mcc_3R_45()) return true;
    return false;
  }

  private bool mcc_3R_100() {
    if (mcc_3R_149()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_150()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_119() {
    if (mcc_scan_token(HEXNUMBER_SHORT)) return true;
    return false;
  }

  private bool mcc_3R_118() {
    if (mcc_scan_token(HEXNUMBER_BYTE)) return true;
    return false;
  }

  private bool mcc_3R_117() {
    if (mcc_scan_token(HEXNUMBER)) return true;
    return false;
  }

  private bool mcc_3R_116() {
    if (mcc_scan_token(NUMBER_LONG)) return true;
    return false;
  }

  private bool mcc_3R_115() {
    if (mcc_scan_token(NUMBER_SHORT)) return true;
    return false;
  }

  private bool mcc_3R_163() {
    if (mcc_scan_token(QUESTIONMARK)) return true;
    return false;
  }

  private bool mcc_3R_114() {
    if (mcc_scan_token(NUMBER_BYTE)) return true;
    return false;
  }

  private bool mcc_3R_214() {
    if (mcc_3R_48()) return true;
    return false;
  }

  private bool mcc_3R_195() {
    if (mcc_scan_token(MAP)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    return false;
  }

  private bool mcc_3_44() {
    if (mcc_3R_59()) return true;
    if (mcc_scan_token(EQUAL)) return true;
    return false;
  }

  private bool mcc_3R_61() {
    if (mcc_3R_100()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_103()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_113() {
    if (mcc_scan_token(NUMBER)) return true;
    return false;
  }

  private bool mcc_3R_43() {
    if (mcc_3R_45()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3_20()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_77() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3_45() {
    if (mcc_3R_61()) return true;
    return false;
  }

  private bool mcc_3R_216() {
    if (mcc_scan_token(QUESTIONMARK)) return true;
    return false;
  }

  private bool mcc_3_43() {
    if (mcc_3R_49()) return true;
    if (mcc_scan_token(GREATEREQUAL)) return true;
    return false;
  }

  private bool mcc_3R_65() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_113()) {
    mcc_scanpos = xsp;
    if (mcc_3R_114()) {
    mcc_scanpos = xsp;
    if (mcc_3R_115()) {
    mcc_scanpos = xsp;
    if (mcc_3R_116()) {
    mcc_scanpos = xsp;
    if (mcc_3R_117()) {
    mcc_scanpos = xsp;
    if (mcc_3R_118()) {
    mcc_scanpos = xsp;
    if (mcc_3R_119()) {
    mcc_scanpos = xsp;
    if (mcc_3R_120()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private bool mcc_3R_42() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_78()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_32() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_65()) {
    mcc_scanpos = xsp;
    if (mcc_3R_66()) {
    mcc_scanpos = xsp;
    if (mcc_3R_67()) {
    mcc_scanpos = xsp;
    if (mcc_3R_68()) {
    mcc_scanpos = xsp;
    if (mcc_3R_69()) {
    mcc_scanpos = xsp;
    if (mcc_3R_70()) {
    mcc_scanpos = xsp;
    if (mcc_3R_71()) {
    mcc_scanpos = xsp;
    if (mcc_3_1()) {
    mcc_scanpos = xsp;
    lookingAhead = true;
    mcc_semLA = GetToken(1).kind==WORD && varDecls.Lookup(GetToken(1).image)==null && TypesHelper.GetNodeOrEdgeType(GetToken(1).image, model)!=null;
    lookingAhead = false;
    if (!mcc_semLA || mcc_3R_72()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private bool mcc_3_19() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_42()) mcc_scanpos = xsp;
    if (mcc_scan_token(CIRCUMFLEX)) return true;
    if (mcc_3R_43()) return true;
    return false;
  }

  private bool mcc_3R_205() {
    if (mcc_scan_token(LPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_184() {
    if (mcc_scan_token(MAP)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    return false;
  }

  private bool mcc_3R_41() {
    if (mcc_3R_43()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3_19()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_194() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    return false;
  }

  private bool mcc_3R_76() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_233() {
    if (mcc_3R_61()) return true;
    return false;
  }

  private bool mcc_3R_162() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_147() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_162()) {
    mcc_scanpos = xsp;
    if (mcc_3R_163()) return true;
    }
    return false;
  }

  private bool mcc_3R_94() {
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_147()) { mcc_scanpos = xsp; break; }
    }
    if (mcc_3R_31()) return true;
    xsp = mcc_scanpos;
    if (mcc_3R_205()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_213() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_40() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_77()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_197() {
    if (mcc_3R_48()) return true;
    return false;
  }

  private bool mcc_3_18() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_40()) mcc_scanpos = xsp;
    if (mcc_scan_token(PIPE)) return true;
    if (mcc_3R_41()) return true;
    return false;
  }

  private bool mcc_3R_146() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_213()) mcc_scanpos = xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_214()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_215() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_204() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_215()) {
    mcc_scanpos = xsp;
    if (mcc_3R_216()) return true;
    }
    return false;
  }

  private bool mcc_3R_193() {
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_187() {
    if (mcc_scan_token(COMMA)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_197()) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(21)) return true;
    }
    return false;
  }

  private bool mcc_3R_186() {
    if (mcc_scan_token(COLON)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_193()) {
    mcc_scanpos = xsp;
    if (mcc_3R_194()) {
    mcc_scanpos = xsp;
    if (mcc_3R_195()) {
    mcc_scanpos = xsp;
    if (mcc_3R_196()) return true;
    }
    }
    }
    return false;
  }

  private bool mcc_3_42() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    if (mcc_3R_61()) return true;
    if (mcc_scan_token(RBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3R_183() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    return false;
  }

  private bool mcc_3R_39() {
    if (mcc_3R_41()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3_18()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_93() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_146()) mcc_scanpos = xsp;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_204()) { mcc_scanpos = xsp; break; }
    }
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_99() {
    if (mcc_3R_48()) return true;
    return false;
  }

  private bool mcc_3R_75() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_122() {
    if (mcc_scan_token(NUMDOUBLE)) return true;
    return false;
  }

  private bool mcc_3_41() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(DOT)) return true;
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_159() {
    if (mcc_3R_31()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_186()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_161() {
    if (mcc_3R_48()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_187()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_38() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_76()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_98() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    if (mcc_3R_61()) return true;
    if (mcc_scan_token(RBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3R_182() {
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3_17() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_38()) mcc_scanpos = xsp;
    if (mcc_scan_token(DOUBLEAMPERSAND)) return true;
    if (mcc_3R_39()) return true;
    return false;
  }

  private bool mcc_3_40() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(DOT)) return true;
    if (mcc_scan_token(VISITED)) return true;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    if (mcc_3R_61()) return true;
    if (mcc_scan_token(RBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3R_92() {
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_203()) return true;
    return false;
  }

  private bool mcc_3R_58() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_92()) mcc_scanpos = xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_93()) {
    mcc_scanpos = xsp;
    if (mcc_3R_94()) return true;
    }
    return false;
  }

  private bool mcc_3R_143() {
    if (mcc_scan_token(COMMA)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_159()) {
    mcc_scanpos = xsp;
    if (mcc_3R_160()) return true;
    }
    return false;
  }

  private bool mcc_3R_97() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(DOT)) return true;
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_158() {
    if (mcc_scan_token(COLON)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_182()) {
    mcc_scanpos = xsp;
    if (mcc_3R_183()) {
    mcc_scanpos = xsp;
    if (mcc_3R_184()) {
    mcc_scanpos = xsp;
    if (mcc_3R_185()) return true;
    }
    }
    }
    return false;
  }

  private bool mcc_3R_124() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_145() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(37)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(38)) return true;
    }
    return false;
  }

  private bool mcc_3R_37() {
    if (mcc_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3_17()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_74() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_96() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(DOT)) return true;
    if (mcc_scan_token(VISITED)) return true;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    if (mcc_3R_61()) return true;
    if (mcc_scan_token(RBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3R_144() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(37)) mcc_scanpos = xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_161()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_121() {
    if (mcc_scan_token(NUMFLOAT)) return true;
    return false;
  }

  private bool mcc_3R_90() {
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_145()) { mcc_scanpos = xsp; break; }
    }
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_148() {
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_61()) return true;
    return false;
  }

  private bool mcc_3R_141() {
    if (mcc_3R_31()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_158()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_89() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_144()) mcc_scanpos = xsp;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3R_59() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_95()) {
    mcc_scanpos = xsp;
    if (mcc_3R_96()) {
    mcc_scanpos = xsp;
    if (mcc_3R_97()) {
    mcc_scanpos = xsp;
    if (mcc_3R_98()) {
    mcc_scanpos = xsp;
    if (mcc_3R_99()) return true;
    }
    }
    }
    }
    return false;
  }

  private bool mcc_3R_95() {
    if (mcc_scan_token(YIELD)) return true;
    if (mcc_3R_62()) return true;
    return false;
  }

  private bool mcc_3R_36() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_75()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3_16() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_36()) mcc_scanpos = xsp;
    if (mcc_scan_token(DOUBLEPIPE)) return true;
    if (mcc_3R_37()) return true;
    return false;
  }

  private bool mcc_3R_88() {
    if (mcc_scan_token(LPARENTHESIS)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_141()) {
    mcc_scanpos = xsp;
    if (mcc_3R_142()) return true;
    }
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_143()) { mcc_scanpos = xsp; break; }
    }
    if (mcc_scan_token(RPARENTHESIS)) return true;
    if (mcc_scan_token(EQUAL)) return true;
    return false;
  }

  private bool mcc_3R_52() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_88()) mcc_scanpos = xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_89()) {
    mcc_scanpos = xsp;
    if (mcc_3R_90()) return true;
    }
    return false;
  }

  private bool mcc_3_56() {
    if (mcc_3R_61()) return true;
    return false;
  }

  private bool mcc_3_39() {
    if (mcc_3R_61()) return true;
    return false;
  }

  private bool mcc_3R_35() {
    if (mcc_3R_37()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3_16()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_73() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_124()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_33() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_73()) mcc_scanpos = xsp;
    if (mcc_scan_token(THENRIGHT)) return true;
    if (mcc_3R_35()) return true;
    return false;
  }

  private bool mcc_3_38() {
    if (mcc_3R_60()) return true;
    return false;
  }

  private bool mcc_3R_34() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_74()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3_15() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_34()) mcc_scanpos = xsp;
    if (mcc_scan_token(THENLEFT)) return true;
    if (mcc_3R_35()) return true;
    return false;
  }

  private bool mcc_3_55() {
    if (mcc_3R_61()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_148()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_210() {
    if (mcc_3R_218()) return true;
    return false;
  }

  private bool mcc_3_37() {
    if (mcc_3R_49()) return true;
    return false;
  }

  private bool mcc_3R_209() {
    if (mcc_3R_217()) return true;
    return false;
  }

  private bool mcc_3R_47() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(69)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(70)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(71)) return true;
    }
    }
    return false;
  }

  private bool mcc_3_36() {
    if (mcc_3R_59()) return true;
    if (mcc_scan_token(EQUAL)) return true;
    return false;
  }

  private bool mcc_3_14() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3_15()) {
    mcc_scanpos = xsp;
    if (mcc_3R_33()) return true;
    }
    return false;
  }

  private bool mcc_3R_208() {
    if (mcc_3R_49()) return true;
    return false;
  }

  private bool mcc_3_35() {
    if (mcc_3R_49()) return true;
    if (mcc_scan_token(GREATEREQUAL)) return true;
    return false;
  }

  private bool mcc_3R_217() {
    if (mcc_3R_60()) return true;
    return false;
  }

  private bool mcc_3R_207() {
    if (mcc_3R_59()) return true;
    return false;
  }

  private bool mcc_3R_123() {
    if (mcc_scan_token(DOUBLEQUOTEDTEXT)) return true;
    return false;
  }

  private bool mcc_3R_191() {
    if (mcc_3R_35()) return true;
    return false;
  }

  private bool mcc_3R_206() {
    if (mcc_3R_49()) return true;
    return false;
  }

  private bool mcc_3R_200() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_206()) {
    mcc_scanpos = xsp;
    if (mcc_3R_207()) {
    mcc_scanpos = xsp;
    if (mcc_3R_208()) {
    mcc_scanpos = xsp;
    if (mcc_3R_209()) {
    mcc_scanpos = xsp;
    lookingAhead = true;
    mcc_semLA = GetToken(1).kind==WORD && GetToken(2).kind==LPARENTHESIS
                                && (GetToken(1).image=="vfree" || GetToken(1).image=="vreset"
                                        || GetToken(1).image=="emit" || GetToken(1).image=="record"
                                        || GetToken(1).image=="rem" || GetToken(1).image=="clear");
    lookingAhead = false;
    if (!mcc_semLA || mcc_3R_210()) {
    mcc_scanpos = xsp;
    if (mcc_3_39()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private bool mcc_3R_166() {
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_61()) return true;
    return false;
  }

  private bool mcc_3R_31() {
    if (mcc_scan_token(WORD)) return true;
    return false;
  }

  private bool mcc_3R_192() {
    if (mcc_3R_200()) return true;
    return false;
  }

  private bool mcc_3R_60() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(DOT)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3_55()) mcc_scanpos = xsp;
    if (mcc_scan_token(RPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_190() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_178() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_190()) mcc_scanpos = xsp;
    if (mcc_scan_token(LBRACE)) return true;
    if (mcc_3R_192()) return true;
    return false;
  }

  private bool mcc_3_13() {
    if (mcc_scan_token(ARRAY)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(GREATEREQUAL)) return true;
    return false;
  }

  private bool mcc_3R_91() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3_12() {
    if (mcc_scan_token(MAP)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(GREATEREQUAL)) return true;
    return false;
  }

  private bool mcc_3_7() {
    if (mcc_scan_token(LBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3R_177() {
    if (mcc_scan_token(FOR)) return true;
    if (mcc_scan_token(LBRACE)) return true;
    return false;
  }

  private bool mcc_3R_157() {
    if (mcc_scan_token(LBRACE)) return true;
    return false;
  }

  private bool mcc_3_11() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(GREATEREQUAL)) return true;
    return false;
  }

  private bool mcc_3R_151() {
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_61()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_166()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_156() {
    if (mcc_scan_token(LBRACE)) return true;
    return false;
  }

  private bool mcc_3_10() {
    if (mcc_scan_token(ARRAY)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    return false;
  }

  private bool mcc_3_9() {
    if (mcc_scan_token(MAP)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    return false;
  }

  private bool mcc_3_6() {
    if (mcc_scan_token(LBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3R_140() {
    if (mcc_scan_token(ARRAY)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3_7()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_155() {
    if (mcc_scan_token(LBRACE)) return true;
    return false;
  }

  private bool mcc_3_8() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    return false;
  }

  private bool mcc_3R_139() {
    if (mcc_scan_token(MAP)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_31()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_157()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_154() {
    if (mcc_scan_token(LBRACE)) return true;
    return false;
  }

  private bool mcc_3R_138() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_156()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_176() {
    if (mcc_scan_token(IF)) return true;
    if (mcc_scan_token(LBRACE)) return true;
    return false;
  }

  private bool mcc_3R_137() {
    if (mcc_scan_token(ARRAY)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3_6()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_136() {
    if (mcc_scan_token(MAP)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_155()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_175() {
    if (mcc_scan_token(DIV)) return true;
    if (mcc_3R_191()) return true;
    return false;
  }

  private bool mcc_3R_135() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_154()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_134() {
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_87() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_134()) {
    mcc_scanpos = xsp;
    if (mcc_3R_135()) {
    mcc_scanpos = xsp;
    if (mcc_3R_136()) {
    mcc_scanpos = xsp;
    if (mcc_3R_137()) {
    mcc_scanpos = xsp;
    if (mcc_3R_138()) {
    mcc_scanpos = xsp;
    if (mcc_3R_139()) {
    mcc_scanpos = xsp;
    if (mcc_3R_140()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private bool mcc_3R_174() {
    if (mcc_scan_token(LLANGLE)) return true;
    if (mcc_3R_58()) return true;
    return false;
  }

  private bool mcc_3_54() {
    if (mcc_3R_61()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_151()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_173() {
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_191()) return true;
    return false;
  }

  private bool mcc_3R_172() {
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_191()) return true;
    return false;
  }

  private bool mcc_3R_57() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_91()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3_34() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_57()) mcc_scanpos = xsp;
    if (mcc_scan_token(LBRACE)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_58()) return true;
    return false;
  }

  private bool mcc_3R_56() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_203() {
    if (mcc_3R_48()) return true;
    return false;
  }

  private bool mcc_3R_102() {
    if (mcc_scan_token(DOUBLECOLON)) return true;
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3_33() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_56()) mcc_scanpos = xsp;
    if (mcc_scan_token(AMPERSAND)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_55() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_64() {
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3_54()) mcc_scanpos = xsp;
    if (mcc_scan_token(RPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3_32() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_55()) mcc_scanpos = xsp;
    if (mcc_scan_token(PIPE)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_54() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_101() {
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3_53() {
    if (mcc_3R_61()) return true;
    return false;
  }

  private bool mcc_3_31() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_54()) mcc_scanpos = xsp;
    if (mcc_scan_token(DOUBLEAMPERSAND)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_53() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3_30() {
    if (mcc_scan_token(DOLLAR)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_53()) mcc_scanpos = xsp;
    if (mcc_scan_token(DOUBLEPIPE)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_62() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_101()) {
    mcc_scanpos = xsp;
    if (mcc_3R_102()) return true;
    }
    return false;
  }

  private bool mcc_3_29() {
    if (mcc_3R_52()) return true;
    return false;
  }

  private bool mcc_3R_171() {
    if (mcc_scan_token(DOUBLECOLON)) return true;
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_51() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_170() {
    if (mcc_3R_58()) return true;
    return false;
  }

  private bool mcc_3R_50() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_218() {
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3_28() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_51()) mcc_scanpos = xsp;
    if (mcc_scan_token(FALSE)) return true;
    return false;
  }

  private bool mcc_3R_49() {
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(COLON)) return true;
    if (mcc_3R_87()) return true;
    return false;
  }

  private bool mcc_3_24() {
    if (mcc_3R_46()) return true;
    return false;
  }

  private bool mcc_3_27() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_50()) mcc_scanpos = xsp;
    if (mcc_scan_token(TRUE)) return true;
    return false;
  }

  private bool mcc_3R_112() {
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_61()) return true;
    if (mcc_scan_token(RPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_86() {
    if (mcc_scan_token(DOUBLECOLON)) return true;
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3_26() {
    if (mcc_3R_49()) return true;
    return false;
  }

  private bool mcc_3R_111() {
    if (mcc_scan_token(AT)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_47()) return true;
    if (mcc_scan_token(RPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_169() {
    if (mcc_scan_token(YIELD)) return true;
    if (mcc_3R_62()) return true;
    return false;
  }

  private bool mcc_3R_110() {
    if (mcc_3R_62()) return true;
    return false;
  }

  private bool mcc_3R_168() {
    if (mcc_3R_49()) return true;
    return false;
  }

  private bool mcc_3R_109() {
    if (mcc_scan_token(DEF)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_232()) return true;
    if (mcc_scan_token(RPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_133() {
    if (mcc_scan_token(COLON)) return true;
    if (mcc_3R_87()) return true;
    return false;
  }

  private bool mcc_3_51() {
    if (mcc_3R_64()) return true;
    return false;
  }

  private bool mcc_3_52() {
    if (mcc_3R_46()) return true;
    return false;
  }

  private bool mcc_3_50() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3_22() {
    if (mcc_3R_46()) return true;
    return false;
  }

  private bool mcc_3R_108() {
    if (mcc_3R_64()) return true;
    return false;
  }

  private bool mcc_3_49() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(DOT)) return true;
    return false;
  }

  private bool mcc_3_21() {
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_234() {
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_233()) return true;
    return false;
  }

  private bool mcc_3_23() {
    if (mcc_scan_token(DOLLAR)) return true;
    if (mcc_scan_token(PERCENT)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_47()) return true;
    return false;
  }

  private bool mcc_3R_85() {
    if (mcc_3R_31()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_133()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_107() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    if (mcc_3R_61()) return true;
    if (mcc_scan_token(RBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3_48() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(DOT)) return true;
    if (mcc_scan_token(VISITED)) return true;
    return false;
  }

  private bool mcc_3R_132() {
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_32()) return true;
    return false;
  }

  private bool mcc_3R_106() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(DOT)) return true;
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_48() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_85()) {
    mcc_scanpos = xsp;
    if (mcc_3R_86()) return true;
    }
    return false;
  }

  private bool mcc_3_25() {
    if (mcc_3R_48()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(5)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(19)) return true;
    }
    return false;
  }

  private bool mcc_3_47() {
    if (mcc_3R_60()) return true;
    return false;
  }

  private bool mcc_3R_230() {
    if (mcc_scan_token(IN)) return true;
    if (mcc_3R_219()) return true;
    return false;
  }

  private bool mcc_3_4() {
    if (mcc_3R_32()) return true;
    return false;
  }

  private bool mcc_3R_105() {
    if (mcc_3R_62()) return true;
    if (mcc_scan_token(DOT)) return true;
    if (mcc_scan_token(VISITED)) return true;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    if (mcc_3R_61()) return true;
    if (mcc_scan_token(RBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3R_229() {
    if (mcc_scan_token(GREATEREQUAL)) return true;
    if (mcc_3R_219()) return true;
    return false;
  }

  private bool mcc_3R_228() {
    if (mcc_scan_token(LOWEREQUAL)) return true;
    if (mcc_3R_219()) return true;
    return false;
  }

  private bool mcc_3R_227() {
    if (mcc_scan_token(RANGLE)) return true;
    if (mcc_3R_219()) return true;
    return false;
  }

  private bool mcc_3R_131() {
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_32()) return true;
    if (mcc_scan_token(ARROW)) return true;
    if (mcc_3R_32()) return true;
    return false;
  }

  private bool mcc_3R_223() {
    if (mcc_scan_token(STRUCTURALEQUAL)) return true;
    if (mcc_3R_211()) return true;
    return false;
  }

  private bool mcc_3R_232() {
    if (mcc_3R_233()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_234()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_222() {
    if (mcc_scan_token(INEQUALITY)) return true;
    if (mcc_3R_211()) return true;
    return false;
  }

  private bool mcc_3R_167() {
    if (mcc_3R_48()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(5)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(19)) return true;
    }
    return false;
  }

  private bool mcc_3R_152() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_167()) {
    mcc_scanpos = xsp;
    if (mcc_3R_168()) {
    mcc_scanpos = xsp;
    if (mcc_3R_169()) {
    mcc_scanpos = xsp;
    if (mcc_3_27()) {
    mcc_scanpos = xsp;
    if (mcc_3_28()) {
    mcc_scanpos = xsp;
    if (mcc_3R_170()) {
    mcc_scanpos = xsp;
    if (mcc_3R_171()) {
    mcc_scanpos = xsp;
    if (mcc_3_30()) {
    mcc_scanpos = xsp;
    if (mcc_3_31()) {
    mcc_scanpos = xsp;
    if (mcc_3_32()) {
    mcc_scanpos = xsp;
    if (mcc_3_33()) {
    mcc_scanpos = xsp;
    if (mcc_3_34()) {
    mcc_scanpos = xsp;
    if (mcc_3R_172()) {
    mcc_scanpos = xsp;
    if (mcc_3R_173()) {
    mcc_scanpos = xsp;
    if (mcc_3R_174()) {
    mcc_scanpos = xsp;
    if (mcc_3R_175()) {
    mcc_scanpos = xsp;
    if (mcc_3R_176()) {
    mcc_scanpos = xsp;
    if (mcc_3R_177()) {
    mcc_scanpos = xsp;
    if (mcc_3R_178()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private bool mcc_3R_63() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_104()) {
    mcc_scanpos = xsp;
    if (mcc_3R_105()) {
    mcc_scanpos = xsp;
    if (mcc_3R_106()) {
    mcc_scanpos = xsp;
    if (mcc_3R_107()) {
    mcc_scanpos = xsp;
    if (mcc_3R_108()) {
    mcc_scanpos = xsp;
    if (mcc_3_52()) {
    mcc_scanpos = xsp;
    if (mcc_3R_109()) {
    mcc_scanpos = xsp;
    if (mcc_3R_110()) {
    mcc_scanpos = xsp;
    if (mcc_3R_111()) {
    mcc_scanpos = xsp;
    if (mcc_3R_112()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private bool mcc_3R_104() {
    if (mcc_3R_60()) return true;
    return false;
  }

  private bool mcc_3R_225() {
    if (mcc_scan_token(PLUS)) return true;
    if (mcc_3R_224()) return true;
    return false;
  }

  private bool mcc_3_3() {
    if (mcc_3R_32()) return true;
    if (mcc_scan_token(ARROW)) return true;
    if (mcc_3R_32()) return true;
    return false;
  }

  private bool mcc_3R_130() {
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_32()) return true;
    return false;
  }

  private bool mcc_3R_84() {
    if (mcc_scan_token(ARRAY)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    if (mcc_scan_token(LBOXBRACKET)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3_4()) mcc_scanpos = xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_132()) { mcc_scanpos = xsp; break; }
    }
    if (mcc_scan_token(RBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3_46() {
    if (mcc_3R_63()) return true;
    return false;
  }

  private bool mcc_3R_226() {
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_219()) return true;
    return false;
  }

  private bool mcc_3R_220() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_226()) {
    mcc_scanpos = xsp;
    if (mcc_3R_227()) {
    mcc_scanpos = xsp;
    if (mcc_3R_228()) {
    mcc_scanpos = xsp;
    if (mcc_3R_229()) {
    mcc_scanpos = xsp;
    if (mcc_3R_230()) return true;
    }
    }
    }
    }
    return false;
  }

  private bool mcc_3_2() {
    if (mcc_3R_32()) return true;
    return false;
  }

  private bool mcc_3R_231() {
    if (mcc_scan_token(EXCLAMATIONMARK)) return true;
    if (mcc_3R_63()) return true;
    return false;
  }

  private bool mcc_3R_224() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_231()) {
    mcc_scanpos = xsp;
    if (mcc_3_46()) return true;
    }
    return false;
  }

  private bool mcc_3R_221() {
    if (mcc_scan_token(EQUALITY)) return true;
    if (mcc_3R_211()) return true;
    return false;
  }

  private bool mcc_3R_212() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_221()) {
    mcc_scanpos = xsp;
    if (mcc_3R_222()) {
    mcc_scanpos = xsp;
    if (mcc_3R_223()) return true;
    }
    }
    return false;
  }

  private bool mcc_3R_219() {
    if (mcc_3R_224()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_225()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_83() {
    if (mcc_scan_token(MAP)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(COMMA)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    if (mcc_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3_3()) mcc_scanpos = xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_131()) { mcc_scanpos = xsp; break; }
    }
    if (mcc_scan_token(RBRACE)) return true;
    return false;
  }

  private bool mcc_3R_202() {
    if (mcc_scan_token(AMPERSAND)) return true;
    if (mcc_3R_201()) return true;
    return false;
  }

  private bool mcc_3R_181() {
    if (mcc_scan_token(LBOXBRACKET)) return true;
    return false;
  }

  private bool mcc_3R_180() {
    if (mcc_scan_token(PLUS)) return true;
    return false;
  }

  private bool mcc_3R_160() {
    if (mcc_scan_token(DOUBLECOLON)) return true;
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_211() {
    if (mcc_3R_219()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_220()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_199() {
    if (mcc_scan_token(CIRCUMFLEX)) return true;
    if (mcc_3R_198()) return true;
    return false;
  }

  private bool mcc_3R_179() {
    if (mcc_scan_token(STAR)) return true;
    return false;
  }

  private bool mcc_3R_153() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_179()) {
    mcc_scanpos = xsp;
    if (mcc_3R_180()) {
    mcc_scanpos = xsp;
    if (mcc_3R_181()) return true;
    }
    }
    return false;
  }

  private bool mcc_3R_82() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    if (mcc_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3_2()) mcc_scanpos = xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_130()) { mcc_scanpos = xsp; break; }
    }
    if (mcc_scan_token(RBRACE)) return true;
    return false;
  }

  private bool mcc_3_5() {
    if (mcc_3R_32()) return true;
    return false;
  }

  private bool mcc_3R_189() {
    if (mcc_scan_token(PIPE)) return true;
    if (mcc_3R_188()) return true;
    return false;
  }

  private bool mcc_3R_201() {
    if (mcc_3R_211()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_212()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_46() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3_5()) {
    mcc_scanpos = xsp;
    if (mcc_3R_82()) {
    mcc_scanpos = xsp;
    if (mcc_3R_83()) {
    mcc_scanpos = xsp;
    if (mcc_3R_84()) return true;
    }
    }
    }
    return false;
  }

  private bool mcc_3R_142() {
    if (mcc_scan_token(DOUBLECOLON)) return true;
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_165() {
    if (mcc_scan_token(DOUBLEAMPERSAND)) return true;
    if (mcc_3R_164()) return true;
    return false;
  }

  private bool mcc_3R_198() {
    if (mcc_3R_201()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_202()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_125() {
    if (mcc_3R_152()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_153()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3R_129() {
    return false;
  }

  private bool mcc_3R_128() {
    if (mcc_scan_token(BAND_TO)) return true;
    return false;
  }

  private bool mcc_3R_72() {
    if (mcc_3R_31()) return true;
    return false;
  }

  private bool mcc_3R_127() {
    if (mcc_scan_token(BOR_TO)) return true;
    return false;
  }

  private bool mcc_3R_126() {
    if (mcc_scan_token(ASSIGN_TO)) return true;
    return false;
  }

  private bool mcc_3R_196() {
    if (mcc_scan_token(ARRAY)) return true;
    if (mcc_scan_token(LANGLE)) return true;
    if (mcc_3R_31()) return true;
    if (mcc_scan_token(RANGLE)) return true;
    return false;
  }

  private bool mcc_3R_150() {
    if (mcc_scan_token(DOUBLEPIPE)) return true;
    if (mcc_3R_149()) return true;
    return false;
  }

  private bool mcc_3R_79() {
    if (mcc_scan_token(PERCENT)) return true;
    return false;
  }

  private bool mcc_3R_188() {
    if (mcc_3R_198()) return true;
    Token xsp;
    while (true) {
      xsp = mcc_scanpos;
      if (mcc_3R_199()) { mcc_scanpos = xsp; break; }
    }
    return false;
  }

  private bool mcc_3R_103() {
    if (mcc_scan_token(QUESTIONMARK)) return true;
    if (mcc_3R_61()) return true;
    if (mcc_scan_token(COLON)) return true;
    if (mcc_3R_61()) return true;
    return false;
  }

  public SequenceParserTokenManager token_source;
  SimpleCharStream mcc_input_stream;
  public Token token, mcc_nt;
  private int mcc_ntk;
  private Token mcc_scanpos, mcc_lastpos;
  private int mcc_la;
  public bool lookingAhead = false;
  private bool mcc_semLA;
  private int mcc_gen;
  private int[] mcc_la1 = new int[120];
  static private int[] mcc_la1_0;
  static private int[] mcc_la1_1;
  static private int[] mcc_la1_2;
  static SequenceParser() {
      mcc_gla1_0();
      mcc_gla1_1();
      mcc_gla1_2();
   }
   private static void mcc_gla1_0() {
      mcc_la1_0 = new int[] {0,0,0,0,512,512,512,0,512,0,0,0,512,512,0,0,0,0,0,33554432,0,0,1024,0,1024,1024,0,1024,0,1024,0,1024,0,1024,0,1024,448,448,-1417673728,2097152,0,6291456,140509184,140509184,524320,0,0,33555456,0,0,0,0,512,0,512,0,512,0,512,0,1024,512,0,0,0,0,0,0,0,-1568669696,0,0,0,0,8192,2048,16384,32768,4096,1245184,1245184,1611399168,1611399168,4194304,16777216,33554432,512,512,512,0,512,0,0,0,512,0,0,0,33554432,0,2097152,512,0,1024,0,0,134218752,33554432,0,2097152,512,0,1024,0,0,33554432,0,0,33554432,134218752,};
   }
   private static void mcc_gla1_1() {
      mcc_la1_1 = new int[] {0,536870912,-536870912,-335540736,0,0,0,28672,0,8,16,16,0,0,2,2,2,2,0,0,8,32,0,32,0,2097152,32,0,32,0,32,0,32,0,32,0,0,0,33752690,536870912,8,536870912,0,0,0,32,16,0,16,32,32,32,0,32,0,32,0,32,0,32,0,0,12582912,4194304,32768,294912,32,33554432,16,196642,4194304,33554432,16,64,0,0,0,0,0,0,0,262144,262144,0,0,400,0,0,0,524288,0,28672,8,16,0,28672,8,16,0,32,16,0,16,0,96,96,96,0,32,16,0,16,0,96,96,0,96,96,0,96,};
   }
   private static void mcc_gla1_2() {
      mcc_la1_2 = new int[] {224,2,31,63,0,0,0,0,0,0,128,128,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,2,0,2,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,128,0,128,0,128,0,128,0,0,128,0,128,0,0,0,128,0,0,128,0,128,0,0,0,0,0,0,0,128,};
   }
  private MccCalls[] mcc_2_rtns = new MccCalls[56];
  private bool mcc_rescan = false;
  private int mcc_gc = 0;

  public SequenceParser(System.IO.Stream stream) {
    mcc_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SequenceParserTokenManager(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 120; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public void ReInit(System.IO.Stream stream) {
    mcc_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 120; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public SequenceParser(System.IO.TextReader stream) {
    mcc_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SequenceParserTokenManager(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 120; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public void ReInit(System.IO.TextReader stream) {
    mcc_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 120; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public SequenceParser(SequenceParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 120; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public void ReInit(SequenceParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 120; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

   private Token mcc_consume_token(int kind) {
    Token oldToken = null;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.GetNextToken();
    mcc_ntk = -1;
    if (token.kind == kind) {
      mcc_gen++;
      if (++mcc_gc > 100) {
        mcc_gc = 0;
        for (int i = 0; i < mcc_2_rtns.Length; i++) {
          MccCalls c = mcc_2_rtns[i];
          while (c != null) {
            if (c.gen < mcc_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    mcc_kind = kind;
    throw GenerateParseException();
  }

  private class LookaheadSuccess : System.Exception { }
  private LookaheadSuccess mcc_ls = new LookaheadSuccess();
  private bool mcc_scan_token(int kind) {
    if (mcc_scanpos == mcc_lastpos) {
      mcc_la--;
      if (mcc_scanpos.next == null) {
        mcc_lastpos = mcc_scanpos = mcc_scanpos.next = token_source.GetNextToken();
      } else {
        mcc_lastpos = mcc_scanpos = mcc_scanpos.next;
      }
    } else {
      mcc_scanpos = mcc_scanpos.next;
    }
    if (mcc_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != mcc_scanpos) { i++; tok = tok.next; }
      if (tok != null) mcc_add_error_token(kind, i);
    }
    if (mcc_scanpos.kind != kind) return true;
    if (mcc_la == 0 && mcc_scanpos == mcc_lastpos) throw mcc_ls;
    return false;
  }

  public Token GetNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.GetNextToken();
    mcc_ntk = -1;
    mcc_gen++;
    return token;
  }

  public Token GetToken(int index) {
    Token t = lookingAhead ? mcc_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.GetNextToken();
    }
    return t;
  }

  private int mcc_mntk() {
    if ((mcc_nt=token.next) == null)
      return (mcc_ntk = (token.next=token_source.GetNextToken()).kind);
    else
      return (mcc_ntk = mcc_nt.kind);
  }

  private System.Collections.ArrayList mcc_expentries = new System.Collections.ArrayList();
  private int[] mcc_expentry;
  private int mcc_kind = -1;
  private int[] mcc_lasttokens = new int[100];
  private int mcc_endpos;

  private void mcc_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == mcc_endpos + 1) {
      mcc_lasttokens[mcc_endpos++] = kind;
    } else if (mcc_endpos != 0) {
      mcc_expentry = new int[mcc_endpos];
      for (int i = 0; i < mcc_endpos; i++) {
        mcc_expentry[i] = mcc_lasttokens[i];
      }
      bool exists = false;
      for (System.Collections.IEnumerator e = mcc_expentries.GetEnumerator(); e.MoveNext();) {
        int[] oldentry = (int[])e.Current;
        if (oldentry.Length == mcc_expentry.Length) {
          exists = true;
          for (int i = 0; i < mcc_expentry.Length; i++) {
            if (oldentry[i] != mcc_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) mcc_expentries.Add(mcc_expentry);
      if (pos != 0) mcc_lasttokens[(mcc_endpos = pos) - 1] = kind;
    }
  }

  public ParseException GenerateParseException() {
    mcc_expentries.Clear();
    bool[] la1tokens = new bool[73];
    for (int i = 0; i < 73; i++) {
      la1tokens[i] = false;
    }
    if (mcc_kind >= 0) {
      la1tokens[mcc_kind] = true;
      mcc_kind = -1;
    }
    for (int i = 0; i < 120; i++) {
      if (mcc_la1[i] == mcc_gen) {
        for (int j = 0; j < 32; j++) {
          if ((mcc_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((mcc_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((mcc_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 73; i++) {
      if (la1tokens[i]) {
        mcc_expentry = new int[1];
        mcc_expentry[0] = i;
        mcc_expentries.Add(mcc_expentry);
      }
    }
    mcc_endpos = 0;
    mcc_rescan_token();
    mcc_add_error_token(0, 0);
    int[][] exptokseq = new int[mcc_expentries.Count][];
    for (int i = 0; i < mcc_expentries.Count; i++) {
      exptokseq[i] = (int[])mcc_expentries[i];
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  public void enable_tracing() {
  }

  public void disable_tracing() {
  }

  private void mcc_rescan_token() {
    mcc_rescan = true;
    for (int i = 0; i < 56; i++) {
      MccCalls p = mcc_2_rtns[i];
      do {
        if (p.gen > mcc_gen) {
          mcc_la = p.arg; mcc_lastpos = mcc_scanpos = p.first;
          switch (i) {
            case 0: mcc_3_1(); break;
            case 1: mcc_3_2(); break;
            case 2: mcc_3_3(); break;
            case 3: mcc_3_4(); break;
            case 4: mcc_3_5(); break;
            case 5: mcc_3_6(); break;
            case 6: mcc_3_7(); break;
            case 7: mcc_3_8(); break;
            case 8: mcc_3_9(); break;
            case 9: mcc_3_10(); break;
            case 10: mcc_3_11(); break;
            case 11: mcc_3_12(); break;
            case 12: mcc_3_13(); break;
            case 13: mcc_3_14(); break;
            case 14: mcc_3_15(); break;
            case 15: mcc_3_16(); break;
            case 16: mcc_3_17(); break;
            case 17: mcc_3_18(); break;
            case 18: mcc_3_19(); break;
            case 19: mcc_3_20(); break;
            case 20: mcc_3_21(); break;
            case 21: mcc_3_22(); break;
            case 22: mcc_3_23(); break;
            case 23: mcc_3_24(); break;
            case 24: mcc_3_25(); break;
            case 25: mcc_3_26(); break;
            case 26: mcc_3_27(); break;
            case 27: mcc_3_28(); break;
            case 28: mcc_3_29(); break;
            case 29: mcc_3_30(); break;
            case 30: mcc_3_31(); break;
            case 31: mcc_3_32(); break;
            case 32: mcc_3_33(); break;
            case 33: mcc_3_34(); break;
            case 34: mcc_3_35(); break;
            case 35: mcc_3_36(); break;
            case 36: mcc_3_37(); break;
            case 37: mcc_3_38(); break;
            case 38: mcc_3_39(); break;
            case 39: mcc_3_40(); break;
            case 40: mcc_3_41(); break;
            case 41: mcc_3_42(); break;
            case 42: mcc_3_43(); break;
            case 43: mcc_3_44(); break;
            case 44: mcc_3_45(); break;
            case 45: mcc_3_46(); break;
            case 46: mcc_3_47(); break;
            case 47: mcc_3_48(); break;
            case 48: mcc_3_49(); break;
            case 49: mcc_3_50(); break;
            case 50: mcc_3_51(); break;
            case 51: mcc_3_52(); break;
            case 52: mcc_3_53(); break;
            case 53: mcc_3_54(); break;
            case 54: mcc_3_55(); break;
            case 55: mcc_3_56(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    mcc_rescan = false;
  }

  private void mcc_save(int index, int xla) {
    MccCalls p = mcc_2_rtns[index];
    while (p.gen > mcc_gen) {
      if (p.next == null) { p = p.next = new MccCalls(); break; }
      p = p.next;
    }
    p.gen = mcc_gen + xla - mcc_la; p.first = token; p.arg = xla;
  }

  class MccCalls {
    public int gen;
    public Token first;
    public int arg;
    public MccCalls next;
  }

        }
}
