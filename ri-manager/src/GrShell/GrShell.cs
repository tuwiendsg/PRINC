/* Generated By:CSharpCC: Do not edit this line. GrShell.cs */
    namespace de.unika.ipd.grGen.grShell {

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Text.RegularExpressions;
    using de.unika.ipd.grGen.libGr;
    using de.unika.ipd.grGen.libGr.sequenceParser;
    using grIO;

    public class GrShell : GrShellConstants {
        GrShellImpl impl = null;
        bool valid;
        public bool Quit = false;
        public bool Eof = false;
        public bool ShowPrompt = true;
        bool readFromConsole = false;
        public IWorkaround workaround;
        bool noError;
        bool exitOnError = false;

                public void SetImpl(GrShellImpl impl)
                {
                        this.impl = impl;
                }

        static int Main(string[] args)
        {
            String command = null;
            ArrayList scriptFilename = new ArrayList();
            bool showUsage = false;
            bool nonDebugNonGuiExitOnError = false;
                        int errorCode = 0; // 0==success, the return value

            GrShellImpl.PrintVersion();

            for(int i = 0; i < args.Length; i++)
            {
                if(args[i][0] == '-')
                {
                    if(args[i] == "-C")
                    {
                        if(command != null)
                        {
                            Console.WriteLine("Another command has already been specified with -C!");
                            errorCode = -1;
                            showUsage = true;
                            break;
                        }
                        if(i + 1 >= args.Length)
                        {
                            Console.WriteLine("Missing parameter for -C option!");
                            errorCode = -1;
                            showUsage = true;
                            break;
                        }
                        command = args[i + 1];
                        i++;
                    }
                    else if(args[i] == "-N")
                    {
                        nonDebugNonGuiExitOnError = true;
                    }
                    else if(args[i] == "--help")
                    {
                            Console.WriteLine("Displays help");
                        showUsage = true;
                        break;
                    }
                    else
                    {
                        Console.WriteLine("Illegal option: " + args[i]);
                        showUsage = true;
                        errorCode = -1;
                        break;
                    }
                }
                else
                {
                    String filename = args[i];
                    if(!File.Exists(filename))
                    {
                        filename = filename + ".grs";
                        if(!File.Exists(filename))
                        {
                            Console.WriteLine("The script file \"" + args[i] + "\" or \"" + filename + "\" does not exist!");
                            showUsage = true;
                            errorCode = -1;
                            break;
                        }
                    }
                    scriptFilename.Add(filename);
                }
            }

            // if(args[args.Length - 1] == "--noquitateof") readFromConsole = false;	// TODO: Readd this?

            if(showUsage)
            {
                Console.WriteLine("Usage: GrShell [-C <command>] [<grs-file>]...");
                Console.WriteLine("If called without options, GrShell is started awaiting user input. (Type help for help.)");
                Console.WriteLine("Options:");
                Console.WriteLine("  -C <command> Specifies a command to be executed >first<. Using");
                Console.WriteLine("               ';;' as a delimiter it can actually contain multiple shell commands");
                Console.WriteLine("  -N           non-interactive non-gui shell which exits on error instead of waiting for user input");
                Console.WriteLine("  <grs-file>   Includes the grs-file(s) in the given order");
                return errorCode;
            }

            IWorkaround workaround = WorkaroundManager.Workaround;
            TextReader reader;
            bool showPrompt;
            bool readFromConsole;

            if(command != null)
            {
                reader = new StringReader(command);
                showPrompt = false;
                readFromConsole = false;
            }
            else if(scriptFilename.Count != 0)
            {
                try
                {
                    reader = new StreamReader((String) scriptFilename[0]);
                }
                catch(Exception e)
                {
                    Console.WriteLine("Unable to read file \"" + scriptFilename[0] + "\": " + e.Message);
                    return -1;
                }
                scriptFilename.RemoveAt(0);
                showPrompt = false;
                readFromConsole = false;
            }
            else
            {
                reader = workaround.In;
                showPrompt = true;
                readFromConsole = true;
            }

            GrShell shell = new GrShell(reader);
            shell.ShowPrompt = showPrompt;
            shell.readFromConsole = readFromConsole;
            shell.workaround = workaround;
            shell.impl = new GrShellImpl();
            shell.impl.TokenSourceStack.AddFirst(shell.token_source);
            shell.impl.nonDebugNonGuiExitOnError = nonDebugNonGuiExitOnError;
            try
            {
                while(!shell.Quit && !shell.Eof)
                {
                    bool noError = shell.ParseShellCommand();
                    if(!shell.readFromConsole && (shell.Eof || !noError))
                    {
                            if(nonDebugNonGuiExitOnError && !noError) {
                                    return -1;
                            }

                        if(scriptFilename.Count != 0)
                        {
                            TextReader newReader;
                            try
                            {
                                newReader = new StreamReader((String) scriptFilename[0]);
                            }
                            catch(Exception e)
                            {
                                Console.WriteLine("Unable to read file \"" + scriptFilename[0] + "\": " + e.Message);
                                return -1;
                            }
                            scriptFilename.RemoveAt(0);
                            shell.ReInit(newReader);
                            shell.Eof = false;
                            reader.Close();
                            reader = newReader;
                        }
                        else
                        {
                            shell.ReInit(workaround.In);
                            shell.impl.TokenSourceStack.RemoveFirst();
                            shell.impl.TokenSourceStack.AddFirst(shell.token_source);
                            shell.ShowPrompt = true;
                            shell.readFromConsole = true;
                            shell.Eof = false;
                            reader.Close();
                        }
                    }
                }
            }
                        catch(Exception e)
                        {
                                Console.WriteLine("exit due to " + e.Message);
                                errorCode = -2;
                        }
            finally
            {
                shell.impl.Cleanup();
            }
            return errorCode;
        }

  public String AnyString() {
    Token tok;
     token_source.SwitchTo(WithinAnyString);
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDANYSTRING:
      tok = mcc_consume_token(DOUBLEQUOTEDANYSTRING);
      break;
    case SINGLEQUOTEDANYSTRING:
      tok = mcc_consume_token(SINGLEQUOTEDANYSTRING);
      break;
    case ANYSTRING:
      tok = mcc_consume_token(ANYSTRING);
      break;
    default:
      mcc_la1[0] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
        {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String AttributeName() {
    Token tok;
     token_source.SwitchTo(WithinAttributeName);
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDATTRIBUTENAME:
      tok = mcc_consume_token(DOUBLEQUOTEDATTRIBUTENAME);
      break;
    case SINGLEQUOTEDATTRIBUTENAME:
      tok = mcc_consume_token(SINGLEQUOTEDATTRIBUTENAME);
      break;
    case ATTRIBUTENAME:
      tok = mcc_consume_token(ATTRIBUTENAME);
      break;
    default:
      mcc_la1[1] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
        {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String WordOrText() {
        Token tok;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDTEXT:
      tok = mcc_consume_token(DOUBLEQUOTEDTEXT);
      break;
    case SINGLEQUOTEDTEXT:
      tok = mcc_consume_token(SINGLEQUOTEDTEXT);
      break;
    case WORD:
      tok = mcc_consume_token(WORD);
      break;
    default:
      mcc_la1[2] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
                {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String QuotedText() {
        Token tok;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDTEXT:
      tok = mcc_consume_token(DOUBLEQUOTEDTEXT);
      break;
    case SINGLEQUOTEDTEXT:
      tok = mcc_consume_token(SINGLEQUOTEDTEXT);
      break;
    default:
      mcc_la1[3] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
                {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String TextOrNumber() {
        Token tok;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDTEXT:
      tok = mcc_consume_token(DOUBLEQUOTEDTEXT);
      break;
    case SINGLEQUOTEDTEXT:
      tok = mcc_consume_token(SINGLEQUOTEDTEXT);
      break;
    case WORD:
      tok = mcc_consume_token(WORD);
      break;
    case NUMBER:
      tok = mcc_consume_token(NUMBER);
      break;
    case HEXNUMBER:
      tok = mcc_consume_token(HEXNUMBER);
      break;
    default:
      mcc_la1[4] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
                {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String Variable() {
        Token tok;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDTEXT:
      tok = mcc_consume_token(DOUBLEQUOTEDTEXT);
      break;
    case SINGLEQUOTEDTEXT:
      tok = mcc_consume_token(SINGLEQUOTEDTEXT);
      break;
    case WORD:
      tok = mcc_consume_token(WORD);
      break;
    case DOUBLECOLON:
      mcc_consume_token(DOUBLECOLON);
      tok = mcc_consume_token(WORD);
      break;
    default:
      mcc_la1[5] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
                {return tok.image;}
    throw new Exception("Missing return statement in function");
  }

  public String AttributeValue() {
        Token tok;
        String enumName, enumValue, elemName;
    if (mcc_2_1(2)) {
      enumName = WordOrText();
      mcc_consume_token(DOUBLECOLON);
      enumValue = AttributeName();
                        {return enumName + "::" + enumValue;}
    } else {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case AT:
        mcc_consume_token(AT);
        mcc_consume_token(LPARENTHESIS);
        elemName = WordOrText();
        mcc_consume_token(RPARENTHESIS);
                        {return "@(" + elemName + ")";}
        break;
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOUBLEQUOTEDTEXT:
          tok = mcc_consume_token(DOUBLEQUOTEDTEXT);
          break;
        case SINGLEQUOTEDTEXT:
          tok = mcc_consume_token(SINGLEQUOTEDTEXT);
          break;
        case WORD:
          tok = mcc_consume_token(WORD);
          break;
        case NUMBER:
          tok = mcc_consume_token(NUMBER);
          break;
        case NUMBER_BYTE:
          tok = mcc_consume_token(NUMBER_BYTE);
          break;
        case NUMBER_SHORT:
          tok = mcc_consume_token(NUMBER_SHORT);
          break;
        case NUMBER_LONG:
          tok = mcc_consume_token(NUMBER_LONG);
          break;
        case HEXNUMBER:
          tok = mcc_consume_token(HEXNUMBER);
          break;
        case HEXNUMBER_BYTE:
          tok = mcc_consume_token(HEXNUMBER_BYTE);
          break;
        case HEXNUMBER_SHORT:
          tok = mcc_consume_token(HEXNUMBER_SHORT);
          break;
        case HEXNUMBER_LONG:
          tok = mcc_consume_token(HEXNUMBER_LONG);
          break;
        case NUMFLOAT:
          tok = mcc_consume_token(NUMFLOAT);
          break;
        case NUMDOUBLE:
          tok = mcc_consume_token(NUMDOUBLE);
          break;
        case TRUE:
          tok = mcc_consume_token(TRUE);
          break;
        case FALSE:
          tok = mcc_consume_token(FALSE);
          break;
        case NULL:
          tok = mcc_consume_token(NULL);
          break;
        default:
          mcc_la1[6] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
                        {return tok.image;}
        break;
      default:
        mcc_la1[7] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Exception("Missing return statement in function");
  }

  public int Number() {
        Token t;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NUMBER:
      t = mcc_consume_token(NUMBER);
                        {return Convert.ToInt32(t.image);}
      break;
    case HEXNUMBER:
      t = mcc_consume_token(HEXNUMBER);
            {return Int32.Parse(t.image.Substring("0x".Length), System.Globalization.NumberStyles.HexNumber);}
      break;
    default:
      mcc_la1[8] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public float FloatNumber() {
        Token t;
        float val;
    t = mcc_consume_token(NUMFLOAT);
                // Remove 'F' from the end of the image to parse it
                if(!float.TryParse(t.image.Substring(0, t.image.Length - 1), System.Globalization.NumberStyles.Float,
                                System.Globalization.CultureInfo.InvariantCulture, out val))
                        {throw new ParseException("float expected but found: \"" + t + "\" (" + t.kind + ")");}
                {return val;}
    throw new Exception("Missing return statement in function");
  }

  public double DoubleNumber() {
        Token t;
        String img;
        double val;
    t = mcc_consume_token(NUMDOUBLE);
                // Remove optional 'D' from the end of the image to parse it if necessary
                if(t.image[t.image.Length - 1] == 'd' || t.image[t.image.Length - 1] == 'D')
                        img = t.image.Substring(0, t.image.Length - 1);
                else
                        img = t.image;
                if(!double.TryParse(img, System.Globalization.NumberStyles.Float,
                                System.Globalization.CultureInfo.InvariantCulture, out val))
                        {throw new ParseException("double expected but found: \"" + t + "\" (" + t.kind + ")");}
                {return val;}
    throw new Exception("Missing return statement in function");
  }

  public object NumberOrVar() {
        Token t;
        object val;
        String str;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NUMBER:
      t = mcc_consume_token(NUMBER);
                {return Convert.ToInt32(t.image);}
      break;
    case DOUBLECOLON:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      str = Variable();
                         val = impl.GetVarValue(str); {return val;}
      break;
    default:
      mcc_la1[9] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public bool Bool() {
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case TRUE:
      mcc_consume_token(TRUE);
                 {return true;}
      break;
    case FALSE:
      mcc_consume_token(FALSE);
                  {return false;}
      break;
    default:
      mcc_la1[10] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public object BoolOrVar() {
        object val;
        String str;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case TRUE:
      mcc_consume_token(TRUE);
                 {return true;}
      break;
    case FALSE:
      mcc_consume_token(FALSE);
                  {return false;}
      break;
    case DOUBLECOLON:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      str = Variable();
                         val = impl.GetVarValue(str); {return val;}
      break;
    default:
      mcc_la1[11] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public String Filename() {
    Token tok;
     token_source.SwitchTo(WithinFilename);
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDFILENAME:
      tok = mcc_consume_token(DOUBLEQUOTEDFILENAME);
      break;
    case SINGLEQUOTEDFILENAME:
      tok = mcc_consume_token(SINGLEQUOTEDFILENAME);
      break;
    case FILENAME:
      tok = mcc_consume_token(FILENAME);
      break;
    default:
      mcc_la1[12] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
                {return tok.image.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);}
    throw new Exception("Missing return statement in function");
  }

  public String FilenameOptionalAtEndOfLine() {
    Token tok;
     token_source.SwitchTo(WithinFilename);
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDFILENAME:
    case SINGLEQUOTEDFILENAME:
    case FILENAME:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDFILENAME:
        tok = mcc_consume_token(DOUBLEQUOTEDFILENAME);
        break;
      case SINGLEQUOTEDFILENAME:
        tok = mcc_consume_token(SINGLEQUOTEDFILENAME);
        break;
      case FILENAME:
        tok = mcc_consume_token(FILENAME);
        break;
      default:
        mcc_la1[13] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      LineEnd();
                        {return tok.image.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);}
      break;
    case 0:
    case NLINFILENAME:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NLINFILENAME:
        tok = mcc_consume_token(NLINFILENAME);
        break;
      case 0:
        tok = mcc_consume_token(0);
        break;
      default:
        mcc_la1[14] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
                        {return null;}
      break;
    default:
      mcc_la1[15] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public String FilenameParameterOrEndOfLine() {
    Token tok;
     token_source.SwitchTo(WithinFilename);
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLEQUOTEDFILENAME:
    case SINGLEQUOTEDFILENAME:
    case FILENAME:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDFILENAME:
        tok = mcc_consume_token(DOUBLEQUOTEDFILENAME);
        break;
      case SINGLEQUOTEDFILENAME:
        tok = mcc_consume_token(SINGLEQUOTEDFILENAME);
        break;
      case FILENAME:
        tok = mcc_consume_token(FILENAME);
        break;
      default:
        mcc_la1[16] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
                        {return tok.image.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);}
      break;
    case 0:
    case NLINFILENAME:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NLINFILENAME:
        tok = mcc_consume_token(NLINFILENAME);
        break;
      case 0:
        tok = mcc_consume_token(0);
        break;
      default:
        mcc_la1[17] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
                        {return null;}
      break;
    default:
      mcc_la1[18] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public List<String> FilenameParameterList() {
        List<String> list = new List<String>();
        String cur;
                while((cur = FilenameParameterOrEndOfLine()) != null)
                        list.Add(cur);
                {return list;}
    throw new Exception("Missing return statement in function");
  }

  public String CommandLine() {
    Token tok;
    String str;
     token_source.SwitchTo(WithinCommand);
    tok = mcc_consume_token(COMMANDLINE);
        str = tok.image.Replace("\\\r\n", "").Replace("\\\n", "").Replace("\n", "");
        {return str;}
    throw new Exception("Missing return statement in function");
  }

  public IGraphElement GraphElement() {
        IGraphElement elem;
        String str;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case AT:
      mcc_consume_token(AT);
      mcc_consume_token(LPARENTHESIS);
      str = WordOrText();
      mcc_consume_token(RPARENTHESIS);
                                               elem = impl.GetElemByName(str);
      break;
    case DOUBLECOLON:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      str = Variable();
                                 elem = impl.GetElemByVar(str);
      break;
    default:
      mcc_la1[19] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
          {return elem;}
    throw new Exception("Missing return statement in function");
  }

  public object GraphElementOrVar() {
        object val;
        String str;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case AT:
      mcc_consume_token(AT);
      mcc_consume_token(LPARENTHESIS);
      str = WordOrText();
      mcc_consume_token(RPARENTHESIS);
                                               val = impl.GetElemByName(str);
      break;
    case DOUBLECOLON:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      str = Variable();
                                 val = impl.GetVarValue(str);
      break;
    default:
      mcc_la1[20] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
          {return val;}
    throw new Exception("Missing return statement in function");
  }

  public object GraphElementOrUnquotedVar() {
        object val;
        String str;
        Token tok;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case AT:
      mcc_consume_token(AT);
      mcc_consume_token(LPARENTHESIS);
      str = WordOrText();
      mcc_consume_token(RPARENTHESIS);
                                               val = impl.GetElemByName(str);
      break;
    case WORD:
      tok = mcc_consume_token(WORD);
                             val = impl.GetVarValue(tok.image);
      break;
    case DOUBLECOLON:
      mcc_consume_token(DOUBLECOLON);
      tok = mcc_consume_token(WORD);
                                  val = impl.GetVarValue(tok.image);
      break;
    default:
      mcc_la1[21] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
          {return val;}
    throw new Exception("Missing return statement in function");
  }

  public object GraphElementOrVarOrNull() {
        object val;
        String str;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case AT:
      mcc_consume_token(AT);
      mcc_consume_token(LPARENTHESIS);
      str = WordOrText();
      mcc_consume_token(RPARENTHESIS);
                                               val = impl.GetElemByName(str);
      break;
    case NULL:
      mcc_consume_token(NULL);
                 val = null;
      break;
    case DOUBLECOLON:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      str = Variable();
                                 val = impl.GetVarValue(str);
      break;
    default:
      mcc_la1[22] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
          {return val;}
    throw new Exception("Missing return statement in function");
  }

  public INode Node() {
        INode node;
        String str;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case AT:
      mcc_consume_token(AT);
      mcc_consume_token(LPARENTHESIS);
      str = WordOrText();
      mcc_consume_token(RPARENTHESIS);
                                               node = impl.GetNodeByName(str);
      break;
    case DOUBLECOLON:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      str = Variable();
                                 node = impl.GetNodeByVar(str);
      break;
    default:
      mcc_la1[23] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
          {return node;}
    throw new Exception("Missing return statement in function");
  }

  public IEdge Edge() {
        IEdge edge;
        String str;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case AT:
      mcc_consume_token(AT);
      mcc_consume_token(LPARENTHESIS);
      str = WordOrText();
      mcc_consume_token(RPARENTHESIS);
                                               edge = impl.GetEdgeByName(str);
      break;
    case DOUBLECOLON:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      str = Variable();
                                 edge = impl.GetEdgeByVar(str);
      break;
    default:
      mcc_la1[24] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
          {return edge;}
    throw new Exception("Missing return statement in function");
  }

  public NodeType NodeType() {
        String str;
    str = WordOrText();
                           {return impl.GetNodeType(str);}
    throw new Exception("Missing return statement in function");
  }

  public EdgeType EdgeType() {
        String str;
    str = WordOrText();
                           {return impl.GetEdgeType(str);}
    throw new Exception("Missing return statement in function");
  }

  public ShellGraphProcessingEnvironment Graph() {
        String str;
        int index;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NUMBER:
    case HEXNUMBER:
      index = Number();
                         {return impl.GetShellGraph(index);}
      break;
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      str = WordOrText();
                               {return impl.GetShellGraph(str);}
      break;
    default:
      mcc_la1[25] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
    throw new Exception("Missing return statement in function");
  }

  public object SimpleConstant() {
        object constant = null;
        Token tok;
        string type, value;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NUMBER:
    case NUMBER_BYTE:
    case NUMBER_SHORT:
    case NUMBER_LONG:
    case HEXNUMBER:
    case HEXNUMBER_BYTE:
    case HEXNUMBER_SHORT:
    case HEXNUMBER_LONG:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NUMBER:
        tok = mcc_consume_token(NUMBER);
                               constant = Convert.ToInt32(tok.image);
        break;
      case NUMBER_BYTE:
        tok = mcc_consume_token(NUMBER_BYTE);
                                      constant = Convert.ToSByte(impl.RemoveTypeSuffix(tok.image));
        break;
      case NUMBER_SHORT:
        tok = mcc_consume_token(NUMBER_SHORT);
                                       constant = Convert.ToInt16(impl.RemoveTypeSuffix(tok.image));
        break;
      case NUMBER_LONG:
        tok = mcc_consume_token(NUMBER_LONG);
                                      constant = Convert.ToInt64(impl.RemoveTypeSuffix(tok.image));
        break;
      case HEXNUMBER:
        tok = mcc_consume_token(HEXNUMBER);
                                    constant = Int32.Parse(tok.image.Substring("0x".Length), System.Globalization.NumberStyles.HexNumber);
        break;
      case HEXNUMBER_BYTE:
        tok = mcc_consume_token(HEXNUMBER_BYTE);
                                         constant = SByte.Parse(impl.RemoveTypeSuffix(tok.image.Substring("0x".Length)), System.Globalization.NumberStyles.HexNumber);
        break;
      case HEXNUMBER_SHORT:
        tok = mcc_consume_token(HEXNUMBER_SHORT);
                                          constant = Int16.Parse(impl.RemoveTypeSuffix(tok.image.Substring("0x".Length)), System.Globalization.NumberStyles.HexNumber);
        break;
      case HEXNUMBER_LONG:
        tok = mcc_consume_token(HEXNUMBER_LONG);
                                         constant = Int64.Parse(impl.RemoveTypeSuffix(tok.image.Substring("0x".Length)), System.Globalization.NumberStyles.HexNumber);
        break;
      default:
        mcc_la1[26] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    case NUMFLOAT:
      constant = FloatNumber();
      break;
    case NUMDOUBLE:
      constant = DoubleNumber();
      break;
    default:
      mcc_la1[27] = mcc_gen;
      if (mcc_2_2(2)) {
        constant = QuotedText();
      } else {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case TRUE:
          mcc_consume_token(TRUE);
                         constant = true;
          break;
        case FALSE:
          mcc_consume_token(FALSE);
                          constant = false;
          break;
        case NULL:
          mcc_consume_token(NULL);
                         constant = null;
          break;
        case DOUBLEQUOTEDTEXT:
        case SINGLEQUOTEDTEXT:
        case WORD:
          type = WordOrText();
          mcc_consume_token(DOUBLECOLON);
          value = AttributeName();
                        foreach(EnumAttributeType attrType in impl.CurrentGraph.Model.EnumAttributeTypes)
                        {
                                if(attrType.Name == type)
                                {
                                        Type enumType = attrType.EnumType;
                                        constant = Enum.Parse(enumType, value);
                                        break;
                                }
                        }
                        if(constant==null)
                                {throw new ParseException("Invalid constant \""+type+"::"+value+"\"!");}
          break;
        default:
          mcc_la1[28] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    }
                {return constant;}
    throw new Exception("Missing return statement in function");
  }

  public object Constant() {
        object constant = null;
        object src = null, dst = null;
        string typeName, typeNameDst;
        Type srcType, dstType;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case NUMBER:
    case NUMBER_BYTE:
    case NUMBER_SHORT:
    case NUMBER_LONG:
    case HEXNUMBER:
    case HEXNUMBER_BYTE:
    case HEXNUMBER_SHORT:
    case HEXNUMBER_LONG:
    case NUMFLOAT:
    case NUMDOUBLE:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      constant = SimpleConstant();
      break;
    case SET:
      mcc_consume_token(SET);
      mcc_consume_token(LANGLE);
      typeName = WordOrText();
      mcc_consume_token(RANGLE);
                        srcType = DictionaryListHelper.GetTypeFromNameForDictionaryOrList(typeName, impl.CurrentGraph.Model);
                        dstType = typeof(de.unika.ipd.grGen.libGr.SetValueType);
                        if(srcType!=null)
                                constant = DictionaryListHelper.NewDictionary(srcType, dstType);
                        if(constant==null)
                                {throw new ParseException("Invalid constant \"set<"+typeName+">\"!");}
      mcc_consume_token(LBRACE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        src = SimpleConstant();
                                                 ((IDictionary)constant).Add(src, null);
        break;
      default:
        mcc_la1[29] = mcc_gen;
        ;
        break;
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[30] = mcc_gen;
          goto label_1;
        }
        mcc_consume_token(COMMA);
        src = SimpleConstant();
                                                             ((IDictionary)constant).Add(src, null);
      }label_1: ;
      
      mcc_consume_token(RBRACE);
      break;
    case MAP:
      mcc_consume_token(MAP);
      mcc_consume_token(LANGLE);
      typeName = WordOrText();
      mcc_consume_token(COMMA);
      typeNameDst = WordOrText();
      mcc_consume_token(RANGLE);
                        srcType = DictionaryListHelper.GetTypeFromNameForDictionaryOrList(typeName, impl.CurrentGraph.Model);
                        dstType = DictionaryListHelper.GetTypeFromNameForDictionaryOrList(typeNameDst, impl.CurrentGraph.Model);
                        if(srcType!=null && dstType!=null)
                                constant = DictionaryListHelper.NewDictionary(srcType, dstType);
                        if(constant==null)
                                {throw new ParseException("Invalid constant \"map<"+typeName+","+typeNameDst+">\"!");}
      mcc_consume_token(LBRACE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        src = SimpleConstant();
        mcc_consume_token(ARROW);
        dst = SimpleConstant();
                                                                           ((IDictionary)constant).Add(src, dst);
        break;
      default:
        mcc_la1[31] = mcc_gen;
        ;
        break;
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[32] = mcc_gen;
          goto label_2;
        }
        mcc_consume_token(COMMA);
        src = SimpleConstant();
        mcc_consume_token(ARROW);
        dst = SimpleConstant();
                                                                                       ((IDictionary)constant).Add(src, dst);
      }label_2: ;
      
      mcc_consume_token(RBRACE);
      break;
    case ARRAY:
      mcc_consume_token(ARRAY);
      mcc_consume_token(LANGLE);
      typeName = WordOrText();
      mcc_consume_token(RANGLE);
                        srcType = DictionaryListHelper.GetTypeFromNameForDictionaryOrList(typeName, impl.CurrentGraph.Model);
                        if(srcType!=null)
                                constant = DictionaryListHelper.NewList(srcType);
                        if(constant==null)
                                {throw new ParseException("Invalid constant \"array<"+typeName+">\"!");}
      mcc_consume_token(LBOXBRACKET);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        src = SimpleConstant();
                                                 ((IList)constant).Add(src);
        break;
      default:
        mcc_la1[33] = mcc_gen;
        ;
        break;
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[34] = mcc_gen;
          goto label_3;
        }
        mcc_consume_token(COMMA);
        src = SimpleConstant();
                                                             ((IList)constant).Add(src);
      }label_3: ;
      
      mcc_consume_token(RBOXBRACKET);
      break;
    default:
      mcc_la1[35] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
                {return constant;}
    throw new Exception("Missing return statement in function");
  }

  public void LineEnd() {
          if(Quit) {return;}
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NL:
      mcc_consume_token(NL);
      break;
    case DOUBLESEMICOLON:
      mcc_consume_token(DOUBLESEMICOLON);
      break;
    case 0:
      mcc_consume_token(0);
                                            Eof = true;
      break;
    default:
      mcc_la1[36] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public bool ParseShellCommand() {
      noError = true;
    try {
                  if(ShowPrompt) Console.Write("> ");
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NL:
        mcc_consume_token(NL);
        break;
      case DOUBLESEMICOLON:
        mcc_consume_token(DOUBLESEMICOLON);
        break;
      case 0:
        mcc_consume_token(0);
                                  Eof = true;
        break;
      case DOUBLECOLON:
      case EXCLAMATIONMARK:
      case AT:
      case ASKFOR:
      case CD:
      case CLEAR:
      case CUSTOM:
      case DEBUG:
      case DEF:
      case DELETE:
      case DUMP:
      case ECHO:
      case EDGE:
      case EXEC:
      case EXIT:
      case EXPORT:
      case GRS:
      case HELP:
      case IMPORT:
      case INCLUDE:
      case LS:
      case NEW:
      case NODE:
      case PARSE:
      case PWD:
      case QUIT:
      case RANDOMSEED:
      case RECORD:
      case REDIRECT:
      case REPLAY:
      case RETYPE:
      case SAVE:
      case SELECT:
      case SHOW:
      case SILENCE:
      case SYNC:
      case VALIDATE:
      case XGRS:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        ShellCommand();
        break;
      default:
        mcc_la1[37] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException ex) {
                errorSkip(ex);
                {return false;}
    }
          {return noError;}
    throw new Exception("Missing return statement in function");
  }

  public void ShellCommand() {
        String str1, str2 = null, str3 = null;
        IGraphElement elem;
        object obj, obj2;
        INode node1, node2;
        IEdge edge1, edge2;
        ShellGraphProcessingEnvironment shellGraph = null;
        Sequence seq;
        SequenceDefinition seqDef;
        bool shellGraphSpecified = false, boolVal, boolVal2;
        bool strict = false, exitOnFailure = false, validated = false, onlySpecified = false;
        int num;
        List<String> parameters;
        Param param;
        Token tok;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case EXCLAMATIONMARK:
      mcc_consume_token(EXCLAMATIONMARK);
      str1 = CommandLine();
        impl.ExecuteCommandLine(str1);
      break;
    case CD:
      mcc_consume_token(CD);
      str1 = Filename();
      LineEnd();
                noError = impl.ChangeDirectory(str1);
      break;
    case LS:
      mcc_consume_token(LS);
      LineEnd();
                noError = impl.ListDirectory();
      break;
    case PWD:
      mcc_consume_token(PWD);
      LineEnd();
                noError = impl.PrintWorkingDirectory();
      break;
    case ASKFOR:
      mcc_consume_token(ASKFOR);
                impl.Askfor(null);
      break;
    case CLEAR:
      mcc_consume_token(CLEAR);
      mcc_consume_token(GRAPH);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NUMBER:
      case HEXNUMBER:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        shellGraph = Graph();
                                              shellGraphSpecified = true;
        break;
      default:
        mcc_la1[38] = mcc_gen;
        ;
        break;
      }
      LineEnd();
            if(shellGraphSpecified && shellGraph == null) noError = false;
            else impl.ClearGraph(shellGraph, shellGraphSpecified);
      break;
    case CUSTOM:
      mcc_consume_token(CUSTOM);
      CustomCommand();
      break;
    case DEBUG:
      mcc_consume_token(DEBUG);
      DebugCommand();
      break;
    case DELETE:
      mcc_consume_token(DELETE);
      DeleteCommand();
      break;
    case DUMP:
      mcc_consume_token(DUMP);
      DumpCommand();
      break;
    case ECHO:
      mcc_consume_token(ECHO);
      str1 = QuotedText();
      LineEnd();
        Console.WriteLine(Regex.Unescape(str1));
      break;
    case EDGE:
      mcc_consume_token(EDGE);
      mcc_consume_token(TYPE);
      edge1 = Edge();
      mcc_consume_token(IS);
      edge2 = Edge();
      LineEnd();
                impl.EdgeTypeIsA(edge1, edge2);
      break;
    case EXPORT:
      mcc_consume_token(EXPORT);
      parameters = FilenameParameterList();
                noError = impl.Export(parameters);
      break;
    case GRS:
      mcc_consume_token(GRS);
      str1 = CommandLine();
        Console.WriteLine("The old grs are not supported any longer. Please use the extended graph rewrite sequences exec(/xgrs).");
        noError = false;
      break;
    case HELP:
      mcc_consume_token(HELP);
      parameters = SpacedParametersAndLineEnd();
                impl.Help(parameters);
      break;
    case IMPORT:
      mcc_consume_token(IMPORT);
      parameters = FilenameParameterList();
                noError = impl.Import(parameters);
      break;
    case INCLUDE:
      mcc_consume_token(INCLUDE);
      str1 = Filename();
      LineEnd();
        noError = impl.Include(this, str1, null, null);
      break;
    case NEW:
      mcc_consume_token(NEW);
      NewCommand();
      break;
    case NODE:
      mcc_consume_token(NODE);
      mcc_consume_token(TYPE);
      node1 = Node();
      mcc_consume_token(IS);
      node2 = Node();
      LineEnd();
                impl.NodeTypeIsA(node1, node2);
      break;
    case PARSE:
      mcc_consume_token(PARSE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case FILE:
        mcc_consume_token(FILE);
        str1 = Filename();
        LineEnd();
                    noError = impl.ParseFile(str1);
        break;
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        str1 = WordOrText();
        LineEnd();
                    noError = impl.ParseString(str1);
        break;
      default:
        mcc_la1[39] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    case EXIT:
    case QUIT:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case QUIT:
        mcc_consume_token(QUIT);
        break;
      case EXIT:
        mcc_consume_token(EXIT);
        break;
      default:
        mcc_la1[40] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      LineEnd();
                impl.Quit();
                Quit = true;
      break;
    case RANDOMSEED:
      mcc_consume_token(RANDOMSEED);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NUMBER:
      case HEXNUMBER:
        num = Number();
                        impl.SetRandomSeed(num);
        break;
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        str1 = WordOrText();
                        if(str1 != "time")
                        {
                                Console.WriteLine("The new seed as integer or the word \"time\" for setting the current time as seed expected!");
                                noError = false;
                        }
                        else impl.SetRandomSeed(Environment.TickCount);
        break;
      default:
        mcc_la1[41] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    case RECORD:
      mcc_consume_token(RECORD);
      str1 = Filename();
                                   boolVal=false; boolVal2=false;
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case START:
      case STOP:
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case START:
          mcc_consume_token(START);
                                                                               boolVal=true; boolVal2=true;
          break;
        case STOP:
          mcc_consume_token(STOP);
                                                                                                                         boolVal=true; boolVal2=false;
          break;
        default:
          mcc_la1[42] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        mcc_la1[43] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                noError = impl.Record(str1, boolVal, boolVal2);
      break;
    case REDIRECT:
      mcc_consume_token(REDIRECT);
      RedirectCommand();
      break;
    case REPLAY:
      mcc_consume_token(REPLAY);
      str1 = Filename();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case FROM:
        mcc_consume_token(FROM);
        str2 = QuotedText();
        break;
      default:
        mcc_la1[44] = mcc_gen;
        ;
        break;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case TO:
        mcc_consume_token(TO);
        str3 = QuotedText();
        break;
      default:
        mcc_la1[45] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                noError = impl.Replay(str1, this, str2, str3);
      break;
    case RETYPE:
      mcc_consume_token(RETYPE);
      RetypeCommand();
      break;
    case SAVE:
      mcc_consume_token(SAVE);
      mcc_consume_token(GRAPH);
      str1 = Filename();
      LineEnd();
                impl.SaveGraph(str1);
      break;
    case SELECT:
      mcc_consume_token(SELECT);
      SelectCommand();
      break;
    case SHOW:
      mcc_consume_token(SHOW);
      ShowCommand();
      break;
    case SILENCE:
      mcc_consume_token(SILENCE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case ON:
        mcc_consume_token(ON);
                       impl.Silence = true;
        break;
      case OFF:
        mcc_consume_token(OFF);
                        impl.Silence = false;
        break;
      default:
        mcc_la1[46] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    case SYNC:
      mcc_consume_token(SYNC);
      mcc_consume_token(IO);
      LineEnd();
                impl.SyncIO();
      break;
    case VALIDATE:
      tok = mcc_consume_token(VALIDATE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case EXITONFAILURE:
        mcc_consume_token(EXITONFAILURE);
                                         exitOnFailure = true;
        break;
      default:
        mcc_la1[47] = mcc_gen;
        ;
        break;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case EXEC:
      case XGRS:
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case XGRS:
          mcc_consume_token(XGRS);
          break;
        case EXEC:
          mcc_consume_token(EXEC);
          break;
        default:
          mcc_la1[48] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
        str1 = CommandLine();
            try
            {
                                List<String> warnings = new List<String>();
                seq = SequenceParser.ParseSequence(str1, impl.CurrentActions, warnings);
                foreach(string warning in warnings)
                {
                                        Console.WriteLine("The validate sequence at line " + tok.beginLine + " reported back: " + warning);
                }
                validated = impl.ValidateWithSequence(seq);
                noError = !impl.OperationCancelled;
            }
            catch(SequenceParserException ex)
            {
                    Console.WriteLine("Unable to parse validate sequence at line " + tok.beginLine);
                impl.HandleSequenceParserException(ex);
                noError = false;
            }
            catch(de.unika.ipd.grGen.libGr.sequenceParser.ParseException ex)
            {
                                Console.WriteLine("Unable to execute validate sequence at line " + tok.beginLine + ": " + ex.Message);
                noError = false;
            }
            catch(Exception ex)
            {
                                Console.WriteLine("Unable to execute validate sequence at line " + tok.beginLine + ": " + ex);
                noError = false;
            }
                        if((!validated || !noError) && exitOnFailure)
                        {
                                {throw new Exception("validate (at line " + tok.beginLine + ") failed");}
                        }
        break;
      case 0:
      case NL:
      case DOUBLESEMICOLON:
      case STRICT:
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case STRICT:
          mcc_consume_token(STRICT);
                         strict = true;
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case ONLY:
            mcc_consume_token(ONLY);
            mcc_consume_token(SPECIFIED);
                                                                onlySpecified = true;
            break;
          default:
            mcc_la1[49] = mcc_gen;
            ;
            break;
          }
          break;
        default:
          mcc_la1[50] = mcc_gen;
          ;
          break;
        }
        LineEnd();
                    validated = impl.Validate(strict, onlySpecified);
                        if(!validated && exitOnFailure)
                        {
                                {throw new Exception("validate (at line " + tok.beginLine + ") failed");}
                        }
        break;
      default:
        mcc_la1[51] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      break;
    case EXEC:
    case XGRS:
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case XGRS:
        tok = mcc_consume_token(XGRS);
        break;
      case EXEC:
        tok = mcc_consume_token(EXEC);
        break;
      default:
        mcc_la1[52] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      str1 = CommandLine();
        try
        {
                        List<String> warnings = new List<String>();
            seq = SequenceParser.ParseSequence(str1, impl.CurrentActions, warnings);
                        foreach(string warning in warnings)
                        {
                                Console.WriteLine("The sequence at line " + tok.beginLine + " reported back: " + warning);
                        }
            impl.ApplyRewriteSequence(seq, false);
            noError = !impl.OperationCancelled;
        }
        catch(SequenceParserException ex)
        {
            Console.WriteLine("Unable to parse sequence at line " + tok.beginLine);
            impl.HandleSequenceParserException(ex);
            noError = false;
        }
        catch(de.unika.ipd.grGen.libGr.sequenceParser.ParseException ex)
        {
            Console.WriteLine("Unable to execute sequence at line " + tok.beginLine + ": " + ex.Message);
            noError = false;
        }
        catch(Exception ex)
        {
            Console.WriteLine("Unable to execute sequence at line " + tok.beginLine + ": " + ex);
            noError = false;
        }
      break;
    case DEF:
      tok = mcc_consume_token(DEF);
      str1 = CommandLine();
        try
        {
                        List<String> warnings = new List<String>();
            seqDef = SequenceParser.ParseSequenceDefinition(str1, impl.CurrentActions, warnings);
                        foreach(string warning in warnings)
                        {
                                Console.WriteLine("The sequence definition at line " + tok.beginLine + " reported back: " + warning);
                        }
            impl.DefineRewriteSequence(seqDef);
        }
        catch(SequenceParserException ex)
        {
            Console.WriteLine("Unable to parse sequence definition at line " + tok.beginLine);
            impl.HandleSequenceParserException(ex);
            noError = false;
        }
        catch(de.unika.ipd.grGen.libGr.sequenceParser.ParseException ex)
        {
            Console.WriteLine("Unable to process sequence definition at line " + tok.beginLine + ": " + ex.Message);
            noError = false;
        }
        catch(Exception ex)
        {
            Console.WriteLine("Unable to process sequence definition at line " + tok.beginLine + ": " + ex);
            Console.WriteLine("(You tried to overwrite a compiled sequence?)");
            noError = false;
        }
      break;
    case DOUBLECOLON:
    case AT:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      try {
        if (mcc_2_5(2147483647)) {
          elem = GraphElement();
          mcc_consume_token(DOT);
          str1 = AttributeName();
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case 0:
          case NL:
          case DOUBLESEMICOLON:
            LineEnd();
                    impl.ShowElementAttribute(elem, str1);
            break;
          case EQUAL:
            mcc_consume_token(EQUAL);
                      param = new Param(str1);
            AttributeParamValue(ref param);
            LineEnd();
                        impl.SetElementAttribute(elem, param);
            break;
          case LBOXBRACKET:
            mcc_consume_token(LBOXBRACKET);
            obj = SimpleConstant();
            mcc_consume_token(RBOXBRACKET);
            mcc_consume_token(EQUAL);
            str2 = AttributeValue();
            LineEnd();
                        impl.SetElementAttributeIndexed(elem, str1, str2, obj);
            break;
          default:
            mcc_la1[55] = mcc_gen;
            if (mcc_2_3(2)) {
              mcc_consume_token(DOT);
              mcc_consume_token(ADD);
              mcc_consume_token(LPARENTHESIS);
              obj = SimpleConstant();
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case COMMA:
                mcc_consume_token(COMMA);
                obj2 = SimpleConstant();
                mcc_consume_token(RPARENTHESIS);
                LineEnd();
                                        impl.MapArrayAdd(elem, str1, obj, obj2);
                break;
              case RPARENTHESIS:
                mcc_consume_token(RPARENTHESIS);
                LineEnd();
                                        impl.SetArrayAdd(elem, str1, obj);
                break;
              default:
                mcc_la1[53] = mcc_gen;
                mcc_consume_token(-1);
                throw new ParseException();
              }
            } else {
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case DOT:
                mcc_consume_token(DOT);
                mcc_consume_token(REM);
                mcc_consume_token(LPARENTHESIS);
                switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
                case FALSE:
                case NULL:
                case TRUE:
                case NUMBER:
                case NUMBER_BYTE:
                case NUMBER_SHORT:
                case NUMBER_LONG:
                case HEXNUMBER:
                case HEXNUMBER_BYTE:
                case HEXNUMBER_SHORT:
                case HEXNUMBER_LONG:
                case NUMFLOAT:
                case NUMDOUBLE:
                case DOUBLEQUOTEDTEXT:
                case SINGLEQUOTEDTEXT:
                case WORD:
                  obj = SimpleConstant();
                  mcc_consume_token(RPARENTHESIS);
                  LineEnd();
                                        impl.SetMapArrayRemove(elem, str1, obj);
                  break;
                case RPARENTHESIS:
                  mcc_consume_token(RPARENTHESIS);
                  LineEnd();
                                        impl.SetMapArrayRemove(elem, str1, null);
                  break;
                default:
                  mcc_la1[54] = mcc_gen;
                  mcc_consume_token(-1);
                  throw new ParseException();
                }
                break;
              default:
                mcc_la1[56] = mcc_gen;
                mcc_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
          }
        } else if (mcc_2_6(2)) {
          str1 = Variable();
          mcc_consume_token(EQUAL);
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case ASKFOR:
            mcc_consume_token(ASKFOR);
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case DOUBLEQUOTEDTEXT:
            case SINGLEQUOTEDTEXT:
            case WORD:
              str2 = WordOrText();
                                        obj = impl.Askfor(str2);
                                        if(obj == null) noError = false;
              break;
            case SET:
              mcc_consume_token(SET);
              mcc_consume_token(LANGLE);
              str2 = WordOrText();
              mcc_consume_token(RANGLE);
                                        obj = impl.Askfor("set<"+str2+">");
                                        if(obj == null) noError = false;
              break;
            case MAP:
              mcc_consume_token(MAP);
              mcc_consume_token(LANGLE);
              str2 = WordOrText();
              mcc_consume_token(COMMA);
              str3 = WordOrText();
              mcc_consume_token(RANGLE);
                                        obj = impl.Askfor("map<"+str2+","+str3+">");
                                        if(obj == null) noError = false;
              break;
            case ARRAY:
              mcc_consume_token(ARRAY);
              mcc_consume_token(LANGLE);
              str2 = WordOrText();
              mcc_consume_token(RANGLE);
                                        obj = impl.Askfor("array<"+str2+">");
                                        if(obj == null) noError = false;
              break;
            default:
              mcc_la1[57] = mcc_gen;
              mcc_consume_token(-1);
              throw new ParseException();
            }
            LineEnd();
            break;
          default:
            mcc_la1[59] = mcc_gen;
            if (mcc_2_4(2)) {
              obj = GraphElementOrUnquotedVar();
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case DOT:
                mcc_consume_token(DOT);
                str2 = AnyString();
                                                 obj = impl.GetElementAttribute((IGraphElement) obj, str2);
                break;
              default:
                mcc_la1[58] = mcc_gen;
                ;
                break;
              }
              LineEnd();
            } else {
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case ARRAY:
              case FALSE:
              case MAP:
              case NULL:
              case SET:
              case TRUE:
              case NUMBER:
              case NUMBER_BYTE:
              case NUMBER_SHORT:
              case NUMBER_LONG:
              case HEXNUMBER:
              case HEXNUMBER_BYTE:
              case HEXNUMBER_SHORT:
              case HEXNUMBER_LONG:
              case NUMFLOAT:
              case NUMDOUBLE:
              case DOUBLEQUOTEDTEXT:
              case SINGLEQUOTEDTEXT:
              case WORD:
                obj = Constant();
                LineEnd();
                break;
              default:
                mcc_la1[60] = mcc_gen;
                mcc_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
          }
                        if(noError) impl.SetVariable(str1, obj);
        } else {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case DOUBLECOLON:
          case DOUBLEQUOTEDTEXT:
          case SINGLEQUOTEDTEXT:
          case WORD:
            str1 = Variable();
            mcc_consume_token(LBOXBRACKET);
            obj = SimpleConstant();
            mcc_consume_token(RBOXBRACKET);
            mcc_consume_token(EQUAL);
            obj2 = SimpleConstant();
            LineEnd();
                        impl.SetVariableIndexed(str1, obj2, obj);
            break;
          default:
            mcc_la1[61] = mcc_gen;
            mcc_consume_token(-1);
            throw new ParseException();
          }
        }
      } catch (ParseException ex) {
        {throw new ParseException("Unknown command. Enter \"help\" to get a list of commands.");}
      }
      break;
    default:
      mcc_la1[62] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

///////////////////
// "New" command //
///////////////////
  public void NewCommand() {
        String modelFilename, referencePath, graphName = "DefaultGraph";
        INode srcNode, tgtNode;
        ElementDef elemDef;
        bool directed, on;
    try {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case GRAPH:
        mcc_consume_token(GRAPH);
        modelFilename = Filename();
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOUBLEQUOTEDTEXT:
        case SINGLEQUOTEDTEXT:
        case WORD:
          graphName = WordOrText();
          break;
        default:
          mcc_la1[63] = mcc_gen;
          ;
          break;
        }
        LineEnd();
                        noError = impl.NewGraph(modelFilename, graphName);
        break;
      case ADD:
        mcc_consume_token(ADD);
        mcc_consume_token(REFERENCE);
        referencePath = Filename();
        LineEnd();
                        noError = impl.NewGraphAddReference(referencePath);
        break;
      default:
        mcc_la1[67] = mcc_gen;
        if (mcc_2_7(2)) {
          mcc_consume_token(SET);
          mcc_consume_token(KEEPDEBUG);
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case ON:
            mcc_consume_token(ON);
                                                       on = true;
            break;
          case OFF:
            mcc_consume_token(OFF);
                                                                              on = false;
            break;
          default:
            mcc_la1[64] = mcc_gen;
            mcc_consume_token(-1);
            throw new ParseException();
          }
          LineEnd();
                        noError = impl.NewGraphSetKeepDebug(on);
        } else {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case SET:
            mcc_consume_token(SET);
            mcc_consume_token(LAZYNIC);
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case ON:
              mcc_consume_token(ON);
                                        on = true;
              break;
            case OFF:
              mcc_consume_token(OFF);
                                                               on = false;
              break;
            default:
              mcc_la1[65] = mcc_gen;
              mcc_consume_token(-1);
              throw new ParseException();
            }
            LineEnd();
                        noError = impl.NewGraphSetLazyNIC(on);
            break;
          default:
            mcc_la1[68] = mcc_gen;
            if (mcc_2_8(3)) {
              srcNode = Node();
              mcc_consume_token(MINUS);
              elemDef = ElementDefinition();
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case ARROW:
                mcc_consume_token(ARROW);
                                                                        directed = true;
                break;
              case MINUS:
                mcc_consume_token(MINUS);
                                                                                                   directed = false;
                break;
              default:
                mcc_la1[66] = mcc_gen;
                mcc_consume_token(-1);
                throw new ParseException();
              }
              tgtNode = Node();
              LineEnd();
                        noError = impl.NewEdge(elemDef, srcNode, tgtNode, directed) != null;
            } else if (mcc_2_9(2)) {
              tgtNode = Node();
              mcc_consume_token(183);
              elemDef = ElementDefinition();
              mcc_consume_token(MINUS);
                                                                      directed = true;
              srcNode = Node();
              LineEnd();
                        noError = impl.NewEdge(elemDef, srcNode, tgtNode, directed) != null;
            } else {
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case 0:
              case NL:
              case DOUBLECOLON:
              case COLON:
              case DOUBLESEMICOLON:
              case DOUBLEQUOTEDTEXT:
              case SINGLEQUOTEDTEXT:
              case WORD:
                elemDef = ElementDefinition();
                LineEnd();
                        noError = impl.NewNode(elemDef) != null;
                break;
              default:
                mcc_la1[69] = mcc_gen;
                mcc_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
          }
        }
        break;
      }
    } catch (ParseException ex) {
                Console.WriteLine("Invalid command!");
                impl.HelpNew(new List<String>());
                errorSkipSilent();
                noError = false;
    }
  }

  public ElementDef ElementDefinition() {
        String varName = null, typeName = null, elemName = null;
        ArrayList attributes = new ArrayList();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case DOUBLECOLON:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      varName = Variable();
      break;
    default:
      mcc_la1[70] = mcc_gen;
      ;
      break;
    }
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case COLON:
      mcc_consume_token(COLON);
      typeName = WordOrText();
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case LPARENTHESIS:
        mcc_consume_token(LPARENTHESIS);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case DOLLAR:
        case DOUBLEQUOTEDTEXT:
        case SINGLEQUOTEDTEXT:
        case WORD:
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case DOLLAR:
            mcc_consume_token(DOLLAR);
            mcc_consume_token(EQUAL);
            elemName = WordOrText();
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case COMMA:
              mcc_consume_token(COMMA);
              Attributes(attributes);
              break;
            default:
              mcc_la1[71] = mcc_gen;
              ;
              break;
            }
            break;
          case DOUBLEQUOTEDTEXT:
          case SINGLEQUOTEDTEXT:
          case WORD:
            Attributes(attributes);
            break;
          default:
            mcc_la1[72] = mcc_gen;
            mcc_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          mcc_la1[73] = mcc_gen;
          ;
          break;
        }
        mcc_consume_token(RPARENTHESIS);
        break;
      default:
        mcc_la1[74] = mcc_gen;
        ;
        break;
      }
      break;
    default:
      mcc_la1[75] = mcc_gen;
      ;
      break;
    }
                {return new ElementDef(elemName, varName, typeName, attributes);}
    throw new Exception("Missing return statement in function");
  }

  public void Attributes(ArrayList attributes) {
    SingleAttribute(attributes);
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case COMMA:
        ;
        break;
      default:
        mcc_la1[76] = mcc_gen;
        goto label_4;
      }
      mcc_consume_token(COMMA);
      SingleAttribute(attributes);
    }label_4: ;
    
  }

  public void SingleAttribute(ArrayList attributes) {
        String attribName;
        Param param;
    attribName = WordOrText();
    mcc_consume_token(EQUAL);
                  param = new Param(attribName);
    AttributeParamValue(ref param);
                          attributes.Add(param);
  }

  public void AttributeParamValue(ref Param param) {
        String value, valueTgt;
        String type, typeTgt;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case AT:
    case FALSE:
    case NULL:
    case TRUE:
    case NUMBER:
    case NUMBER_BYTE:
    case NUMBER_SHORT:
    case NUMBER_LONG:
    case HEXNUMBER:
    case HEXNUMBER_BYTE:
    case HEXNUMBER_SHORT:
    case HEXNUMBER_LONG:
    case NUMFLOAT:
    case NUMDOUBLE:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      value = AttributeValue();
                        param.Value = value;
      break;
    case SET:
      mcc_consume_token(SET);
      mcc_consume_token(LANGLE);
      type = WordOrText();
      mcc_consume_token(RANGLE);
                        param.Value = "set";
                        param.Type = type;
                        param.Values = new ArrayList();
      mcc_consume_token(LBRACE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case AT:
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        value = AttributeValue();
                                               param.Values.Add(value);
        break;
      default:
        mcc_la1[77] = mcc_gen;
        ;
        break;
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[78] = mcc_gen;
          goto label_5;
        }
        mcc_consume_token(COMMA);
        value = AttributeValue();
                                                          param.Values.Add(value);
      }label_5: ;
      
      mcc_consume_token(RBRACE);
      break;
    case MAP:
      mcc_consume_token(MAP);
      mcc_consume_token(LANGLE);
      type = WordOrText();
      mcc_consume_token(COMMA);
      typeTgt = WordOrText();
      mcc_consume_token(RANGLE);
                        param.Value = "map";
                        param.Type = type;
                        param.TgtType = typeTgt;
                        param.Values = new ArrayList();
                        param.TgtValues = new ArrayList();
      mcc_consume_token(LBRACE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case AT:
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        value = AttributeValue();
                                               param.Values.Add(value);
        mcc_consume_token(ARROW);
        valueTgt = AttributeValue();
                                                                                                              param.TgtValues.Add(valueTgt);
        break;
      default:
        mcc_la1[79] = mcc_gen;
        ;
        break;
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[80] = mcc_gen;
          goto label_6;
        }
        mcc_consume_token(COMMA);
        value = AttributeValue();
                                                           param.Values.Add(value);
        mcc_consume_token(ARROW);
        valueTgt = AttributeValue();
                                                                                                                          param.TgtValues.Add(valueTgt);
      }label_6: ;
      
      mcc_consume_token(RBRACE);
      break;
    case ARRAY:
      mcc_consume_token(ARRAY);
      mcc_consume_token(LANGLE);
      type = WordOrText();
      mcc_consume_token(RANGLE);
                        param.Value = "array";
                        param.Type = type;
                        param.Values = new ArrayList();
      mcc_consume_token(LBOXBRACKET);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case AT:
      case FALSE:
      case NULL:
      case TRUE:
      case NUMBER:
      case NUMBER_BYTE:
      case NUMBER_SHORT:
      case NUMBER_LONG:
      case HEXNUMBER:
      case HEXNUMBER_BYTE:
      case HEXNUMBER_SHORT:
      case HEXNUMBER_LONG:
      case NUMFLOAT:
      case NUMDOUBLE:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        value = AttributeValue();
                                               param.Values.Add(value);
        break;
      default:
        mcc_la1[81] = mcc_gen;
        ;
        break;
      }
      while (true) {
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COMMA:
          ;
          break;
        default:
          mcc_la1[82] = mcc_gen;
          goto label_7;
        }
        mcc_consume_token(COMMA);
        value = AttributeValue();
                                                          param.Values.Add(value);
      }label_7: ;
      
      mcc_consume_token(RBOXBRACKET);
      break;
    default:
      mcc_la1[83] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

//////////////////////
// "select" command //
//////////////////////
  public void SelectCommand() {
        String str, mainname;
        ArrayList parameters = new ArrayList();
        ShellGraphProcessingEnvironment shellGraph;
    try {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case BACKEND:
        mcc_consume_token(BACKEND);
        str = Filename();
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case COLON:
          mcc_consume_token(COLON);
          Parameters(parameters);
          break;
        default:
          mcc_la1[84] = mcc_gen;
          ;
          break;
        }
        LineEnd();
                        noError = impl.SelectBackend(str, parameters);
        break;
      case GRAPH:
        mcc_consume_token(GRAPH);
        shellGraph = Graph();
        LineEnd();
                        if(shellGraph == null) noError = false;
                        else impl.SelectGraph(shellGraph);
        break;
      case ACTIONS:
        mcc_consume_token(ACTIONS);
        str = Filename();
        LineEnd();
                        noError = impl.SelectActions(str);
        break;
      case PARSER:
        mcc_consume_token(PARSER);
        str = Filename();
        mainname = WordOrText();
        LineEnd();
                        noError = impl.SelectParser(str, mainname);
        break;
      default:
        mcc_la1[85] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException ex) {
                Console.WriteLine("Invalid command!");
                impl.HelpSelect(new List<String>());
                errorSkipSilent();
                noError = false;
    }
  }

  public void Parameters(ArrayList parameters) {
        String str;
    str = WordOrText();
                           parameters.Add(str);
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case COMMA:
        ;
        break;
      default:
        mcc_la1[86] = mcc_gen;
        goto label_8;
      }
      mcc_consume_token(COMMA);
      str = WordOrText();
                                                                          parameters.Add(str);
    }label_8: ;
    
  }

//////////////////////////////////////////////////
// "delete" and "retype" and "redirect" command //
//////////////////////////////////////////////////
  public void DeleteCommand() {
        INode node;
        IEdge edge;
        ShellGraphProcessingEnvironment shellGraph = null;
        bool shellGraphSpecified = false;
    try {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NODE:
        mcc_consume_token(NODE);
        node = Node();
        LineEnd();
                        noError = impl.Remove(node);
        break;
      case EDGE:
        mcc_consume_token(EDGE);
        edge = Edge();
        LineEnd();
                        noError = impl.Remove(edge);
        break;
      case GRAPH:
        mcc_consume_token(GRAPH);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case NUMBER:
        case HEXNUMBER:
        case DOUBLEQUOTEDTEXT:
        case SINGLEQUOTEDTEXT:
        case WORD:
          shellGraph = Graph();
                                              shellGraphSpecified = true;
          break;
        default:
          mcc_la1[87] = mcc_gen;
          ;
          break;
        }
        LineEnd();
                        noError = impl.DestroyGraph(shellGraph, shellGraphSpecified);
        break;
      default:
        mcc_la1[88] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException ex) {
                Console.WriteLine("Invalid command!");
                impl.HelpDelete(new List<String>());
                errorSkipSilent();
                noError = false;
    }
  }

  public void RetypeCommand() {
        INode node;
        IEdge edge;
        String typeName;
    try {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case MINUS:
        mcc_consume_token(MINUS);
        edge = Edge();
        mcc_consume_token(LANGLE);
        typeName = WordOrText();
        mcc_consume_token(RANGLE);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case ARROW:
          mcc_consume_token(ARROW);
          break;
        case MINUS:
          mcc_consume_token(MINUS);
          break;
        default:
          mcc_la1[89] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
        LineEnd();
                        noError = impl.Retype(edge, typeName) != null;
        break;
      case DOUBLECOLON:
      case AT:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        node = Node();
        mcc_consume_token(LANGLE);
        typeName = WordOrText();
        mcc_consume_token(RANGLE);
        LineEnd();
                        noError = impl.Retype(node, typeName) != null;
        break;
      default:
        mcc_la1[90] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException ex) {
                Console.WriteLine("Invalid command!");
                impl.HelpRetype(new List<String>());
                errorSkipSilent();
                noError = false;
    }
  }

  public void RedirectCommand() {
        INode node;
        IEdge edge;
        String str1;
    try {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case EMIT:
        mcc_consume_token(EMIT);
        str1 = Filename();
        LineEnd();
                        noError = impl.RedirectEmit(str1);
        break;
      case DOUBLECOLON:
      case AT:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        edge = Edge();
        str1 = WordOrText();
        node = Node();
        LineEnd();
                        noError = impl.Redirect(edge, str1, node);
        break;
      default:
        mcc_la1[91] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException ex) {
                Console.WriteLine("Invalid command!");
                impl.HelpRedirect(new List<String>());
                errorSkipSilent();
                noError = false;
    }
  }

////////////////////
// "show" command //
////////////////////
  public void ShowCommand() {
        String str;
        String args = null;
        NodeType nodeType = null;
        EdgeType edgeType = null;
        IGraphElement elem = null;
        bool typeProvided = false;
        bool only = false;
    try {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NODES:
        mcc_consume_token(NODES);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case ONLY:
        case DOUBLEQUOTEDTEXT:
        case SINGLEQUOTEDTEXT:
        case WORD:
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case ONLY:
            mcc_consume_token(ONLY);
                                   only=true;
            break;
          default:
            mcc_la1[92] = mcc_gen;
            ;
            break;
          }
          nodeType = NodeType();
                                                                        typeProvided=true;
          break;
        default:
          mcc_la1[93] = mcc_gen;
          ;
          break;
        }
        LineEnd();
                        if(!typeProvided || nodeType != null)
                                impl.ShowNodes(nodeType, only);
        break;
      case EDGES:
        mcc_consume_token(EDGES);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case ONLY:
        case DOUBLEQUOTEDTEXT:
        case SINGLEQUOTEDTEXT:
        case WORD:
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case ONLY:
            mcc_consume_token(ONLY);
                                   only=true;
            break;
          default:
            mcc_la1[94] = mcc_gen;
            ;
            break;
          }
          edgeType = EdgeType();
                                                                        typeProvided=true;
          break;
        default:
          mcc_la1[95] = mcc_gen;
          ;
          break;
        }
        LineEnd();
                        if(!typeProvided || edgeType != null)
                                impl.ShowEdges(edgeType, only);
        break;
      default:
        mcc_la1[101] = mcc_gen;
        if (mcc_2_10(2)) {
          mcc_consume_token(NUM);
          mcc_consume_token(NODES);
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case ONLY:
          case DOUBLEQUOTEDTEXT:
          case SINGLEQUOTEDTEXT:
          case WORD:
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case ONLY:
              mcc_consume_token(ONLY);
                                         only=true;
              break;
            default:
              mcc_la1[96] = mcc_gen;
              ;
              break;
            }
            nodeType = NodeType();
                                                                              typeProvided=true;
            break;
          default:
            mcc_la1[97] = mcc_gen;
            ;
            break;
          }
          LineEnd();
                        if(!typeProvided || nodeType != null)
                                impl.ShowNumNodes(nodeType, only);
        } else {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case NUM:
            mcc_consume_token(NUM);
            mcc_consume_token(EDGES);
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case ONLY:
            case DOUBLEQUOTEDTEXT:
            case SINGLEQUOTEDTEXT:
            case WORD:
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case ONLY:
                mcc_consume_token(ONLY);
                                         only=true;
                break;
              default:
                mcc_la1[98] = mcc_gen;
                ;
                break;
              }
              edgeType = EdgeType();
                                                                              typeProvided=true;
              break;
            default:
              mcc_la1[99] = mcc_gen;
              ;
              break;
            }
            LineEnd();
                        if(!typeProvided || edgeType != null)
                                impl.ShowNumEdges(edgeType, only);
            break;
          case NODE:
            mcc_consume_token(NODE);
            ShowNode();
            break;
          case EDGE:
            mcc_consume_token(EDGE);
            ShowEdge();
            break;
          case VAR:
            mcc_consume_token(VAR);
            ShowVar();
            break;
          case GRAPH:
            mcc_consume_token(GRAPH);
            str = Filename();
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case DOUBLEQUOTEDTEXT:
            case SINGLEQUOTEDTEXT:
            case WORD:
              args = WordOrText();
              break;
            default:
              mcc_la1[100] = mcc_gen;
              ;
              break;
            }
            LineEnd();
                        impl.ShowGraphWith(str, args);
            break;
          case GRAPHS:
            mcc_consume_token(GRAPHS);
            LineEnd();
                        impl.ShowGraphs();
            break;
          case ACTIONS:
            mcc_consume_token(ACTIONS);
            LineEnd();
                        impl.ShowActions();
            break;
          case BACKEND:
            mcc_consume_token(BACKEND);
            LineEnd();
                        impl.ShowBackend();
            break;
          case DOUBLECOLON:
          case AT:
          case DOUBLEQUOTEDTEXT:
          case SINGLEQUOTEDTEXT:
          case WORD:
            elem = GraphElement();
            mcc_consume_token(DOT);
            str = AttributeName();
            LineEnd();
            impl.ShowElementAttribute(elem, str);
            break;
          default:
            mcc_la1[102] = mcc_gen;
            mcc_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      }
    } catch (ParseException ex) {
                Console.WriteLine("Invalid command!");
                impl.HelpShow(new List<String>());
                errorSkipSilent();
                noError = false;
    }
  }

  public void ShowNode() {
        bool only = false;
        INode node;
    NodeType nodeType = null;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case TYPES:
      mcc_consume_token(TYPES);
      LineEnd();
                impl.ShowNodeTypes();
      break;
    case SUPER:
      mcc_consume_token(SUPER);
      mcc_consume_token(TYPES);
      nodeType = NodeType();
      LineEnd();
                impl.ShowSuperTypes(nodeType, true);
      break;
    case SUB:
      mcc_consume_token(SUB);
      mcc_consume_token(TYPES);
      nodeType = NodeType();
      LineEnd();
                impl.ShowSubTypes(nodeType, true);
      break;
    case ATTRIBUTES:
      mcc_consume_token(ATTRIBUTES);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case ONLY:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case ONLY:
          mcc_consume_token(ONLY);
                                only=true;
          break;
        default:
          mcc_la1[103] = mcc_gen;
          ;
          break;
        }
        nodeType = NodeType();
        break;
      default:
        mcc_la1[104] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                impl.ShowAvailableNodeAttributes(only, nodeType);
      break;
    case DOUBLECOLON:
    case AT:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      node = Node();
      LineEnd();
                impl.ShowElementAttributes(node);
      break;
    default:
      mcc_la1[105] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public void ShowEdge() {
        bool only = false;
        IEdge edge;
        EdgeType edgeType = null;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case TYPES:
      mcc_consume_token(TYPES);
      LineEnd();
                impl.ShowEdgeTypes();
      break;
    case SUPER:
      mcc_consume_token(SUPER);
      mcc_consume_token(TYPES);
      edgeType = EdgeType();
      LineEnd();
                impl.ShowSuperTypes(edgeType, false);
      break;
    case SUB:
      mcc_consume_token(SUB);
      mcc_consume_token(TYPES);
      edgeType = EdgeType();
      LineEnd();
                impl.ShowSubTypes(edgeType, false);
      break;
    case ATTRIBUTES:
      mcc_consume_token(ATTRIBUTES);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case ONLY:
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case ONLY:
          mcc_consume_token(ONLY);
                                only = true;
          break;
        default:
          mcc_la1[106] = mcc_gen;
          ;
          break;
        }
        edgeType = EdgeType();
        break;
      default:
        mcc_la1[107] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                impl.ShowAvailableEdgeAttributes(only, edgeType);
      break;
    case DOUBLECOLON:
    case AT:
    case DOUBLEQUOTEDTEXT:
    case SINGLEQUOTEDTEXT:
    case WORD:
      edge = Edge();
      LineEnd();
                impl.ShowElementAttributes(edge);
      break;
    default:
      mcc_la1[108] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public void ShowVar() {
        String str;
    str = Variable();
    LineEnd();
                impl.ShowVar(str);
  }

//////////////////////
// "debug" command" //
//////////////////////
  public void DebugCommand() {
    Sequence seq;
    String str = null, str2;
        Token tok;
    try {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case GRS:
        mcc_consume_token(GRS);
        str = CommandLine();
                        Console.WriteLine("The old grs are not supported any longer. Please use the extended graph rewrite sequences exec(/xgrs).");
                        noError = false;
        break;
      case EXEC:
      case XGRS:
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case XGRS:
          tok = mcc_consume_token(XGRS);
          break;
        case EXEC:
          tok = mcc_consume_token(EXEC);
          break;
        default:
          mcc_la1[109] = mcc_gen;
          mcc_consume_token(-1);
          throw new ParseException();
        }
        str = CommandLine();
                        try
                        {
                                List<String> warnings = new List<String>();
                                seq = SequenceParser.ParseSequence(str, impl.CurrentActions, warnings);
                                foreach(string warning in warnings)
                                {
                                        Console.WriteLine("The debug sequence at line " + tok.beginLine + " reported back: " + warning);
                                }
                                impl.DebugRewriteSequence(seq);
                                noError = !impl.OperationCancelled;
                        }
                        catch(SequenceParserException ex)
                        {
                            Console.WriteLine("Unable to parse debug sequence at line " + tok.beginLine);
                                impl.HandleSequenceParserException(ex);
                                noError = false;
                        }
                        catch(de.unika.ipd.grGen.libGr.sequenceParser.ParseException ex)
                        {
                                Console.WriteLine("Unable to execute debug sequence at line " + tok.beginLine + ": " + ex.Message);
                                noError = false;
                        }
                        catch(Exception ex)
                        {
                    Console.WriteLine("Unable to execute debug sequence at line " + tok.beginLine + ": " + ex);
                                noError = false;
                        }
        break;
      case ENABLE:
        mcc_consume_token(ENABLE);
        LineEnd();
                        impl.SetDebugMode(true);
        break;
      case DISABLE:
        mcc_consume_token(DISABLE);
        LineEnd();
                        impl.SetDebugMode(false);
        break;
      case LAYOUT:
        mcc_consume_token(LAYOUT);
        LineEnd();
                        impl.DebugLayout();
        break;
      default:
        mcc_la1[112] = mcc_gen;
        if (mcc_2_11(2)) {
          mcc_consume_token(SET);
          mcc_consume_token(LAYOUT);
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case OPTION:
            mcc_consume_token(OPTION);
            str = WordOrText();
            str2 = AnyString();
            LineEnd();
                                impl.SetDebugLayoutOption(str, str2);
            break;
          case 0:
          case NL:
          case DOUBLESEMICOLON:
          case DOUBLEQUOTEDTEXT:
          case SINGLEQUOTEDTEXT:
          case WORD:
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case DOUBLEQUOTEDTEXT:
            case SINGLEQUOTEDTEXT:
            case WORD:
              str = WordOrText();
              break;
            default:
              mcc_la1[110] = mcc_gen;
              ;
              break;
            }
            LineEnd();
                                impl.SetDebugLayout(str);
            break;
          default:
            mcc_la1[111] = mcc_gen;
            mcc_consume_token(-1);
            throw new ParseException();
          }
        } else {
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case GET:
            mcc_consume_token(GET);
            mcc_consume_token(LAYOUT);
            mcc_consume_token(OPTIONS);
            LineEnd();
                        impl.GetDebugLayoutOptions();
            break;
          default:
            mcc_la1[113] = mcc_gen;
            if (mcc_2_12(2)) {
              mcc_consume_token(SET);
              mcc_consume_token(NODE);
              DebugSetNode();
            } else {
              switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
              case SET:
                mcc_consume_token(SET);
                mcc_consume_token(EDGE);
                DebugSetEdge();
                break;
              default:
                mcc_la1[114] = mcc_gen;
                mcc_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
          }
        }
        break;
      }
    } catch (ParseException ex) {
                Console.WriteLine("Invalid command!");
                impl.HelpDebug(new List<String>());
                errorSkipSilent();
                noError = false;
    }
  }

  public void DebugSetNode() {
        String mode = null, colorName = null, shapeName = null;
    mcc_consume_token(MODE);
    mode = WordOrText();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case COLOR:
      mcc_consume_token(COLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[115] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDebugNodeModeColor(mode, colorName);
      break;
    case BORDERCOLOR:
      mcc_consume_token(BORDERCOLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[116] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDebugNodeModeBorderColor(mode, colorName);
      break;
    case SHAPE:
      mcc_consume_token(SHAPE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        shapeName = WordOrText();
        break;
      default:
        mcc_la1[117] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDebugNodeModeShape(mode, shapeName);
      break;
    case TEXTCOLOR:
      mcc_consume_token(TEXTCOLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[118] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDebugNodeModeTextColor(mode, colorName);
      break;
    default:
      mcc_la1[119] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public void DebugSetEdge() {
        String mode = null, colorName = null, styleName = null;
        int thickness = 0;
    mcc_consume_token(MODE);
    mode = WordOrText();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case COLOR:
      mcc_consume_token(COLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[120] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDebugEdgeModeColor(mode, colorName);
      break;
    case TEXTCOLOR:
      mcc_consume_token(TEXTCOLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[121] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDebugEdgeModeTextColor(mode, colorName);
      break;
    case THICKNESS:
      mcc_consume_token(THICKNESS);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NUMBER:
      case HEXNUMBER:
        thickness = Number();
        break;
      default:
        mcc_la1[122] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDebugEdgeModeThickness(mode, thickness);
      break;
    case LINESTYLE:
      mcc_consume_token(LINESTYLE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        styleName = WordOrText();
        break;
      default:
        mcc_la1[123] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDebugEdgeModeStyle(mode, styleName);
      break;
    default:
      mcc_la1[124] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

/////////////////////
// "dump" commands //
/////////////////////
  public void DumpCommand() {
        String filename;
    try {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case GRAPH:
        mcc_consume_token(GRAPH);
        filename = Filename();
        LineEnd();
                        impl.DumpGraph(filename);
        break;
      case SET:
        mcc_consume_token(SET);
        DumpSet();
        break;
      case ADD:
        mcc_consume_token(ADD);
        DumpAdd();
        break;
      case RESET:
        mcc_consume_token(RESET);
        LineEnd();
                        impl.DumpReset();
        break;
      default:
        mcc_la1[125] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException ex) {
                Console.WriteLine("Invalid command!");
                impl.HelpDump(new List<String>());
                errorSkipSilent();
                noError = false;
    }
  }

  public void DumpSet() {
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NODE:
      mcc_consume_token(NODE);
      DumpSetNode();
      break;
    case EDGE:
      mcc_consume_token(EDGE);
      DumpSetEdge();
      break;
    default:
      mcc_la1[126] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public void DumpSetNode() {
        NodeType nodeType;
        String colorName = null, shapeName = null, labelStr = null;
        bool only = false;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case ONLY:
      mcc_consume_token(ONLY);
                  only=true;
      break;
    default:
      mcc_la1[127] = mcc_gen;
      ;
      break;
    }
    nodeType = NodeType();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case COLOR:
      mcc_consume_token(COLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[128] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDumpNodeTypeColor(nodeType, colorName, only);
      break;
    case BORDERCOLOR:
      mcc_consume_token(BORDERCOLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[129] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDumpNodeTypeBorderColor(nodeType, colorName, only);
      break;
    case SHAPE:
      mcc_consume_token(SHAPE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        shapeName = WordOrText();
        break;
      default:
        mcc_la1[130] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDumpNodeTypeShape(nodeType, shapeName, only);
      break;
    case TEXTCOLOR:
      mcc_consume_token(TEXTCOLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[131] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDumpNodeTypeTextColor(nodeType, colorName, only);
      break;
    case LABELS:
      mcc_consume_token(LABELS);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case ON:
        mcc_consume_token(ON);
        break;
      case OFF:
        mcc_consume_token(OFF);
                                         labelStr = "";
        break;
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        labelStr = WordOrText();
        break;
      default:
        mcc_la1[132] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      LineEnd();
                        noError = impl.SetDumpLabel(nodeType, labelStr, only);
      break;
    default:
      mcc_la1[133] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public void DumpSetEdge() {
        EdgeType edgeType;
        String colorName = null, styleName = null, labelStr = null;
        bool only = false;
        int thickness = 0;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case ONLY:
      mcc_consume_token(ONLY);
                  only=true;
      break;
    default:
      mcc_la1[134] = mcc_gen;
      ;
      break;
    }
    edgeType = EdgeType();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case COLOR:
      mcc_consume_token(COLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[135] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDumpEdgeTypeColor(edgeType, colorName, only);
      break;
    case TEXTCOLOR:
      mcc_consume_token(TEXTCOLOR);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        colorName = WordOrText();
        break;
      default:
        mcc_la1[136] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDumpEdgeTypeTextColor(edgeType, colorName, only);
      break;
    case THICKNESS:
      mcc_consume_token(THICKNESS);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case NUMBER:
      case HEXNUMBER:
        thickness = Number();
        break;
      default:
        mcc_la1[137] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDumpEdgeTypeThickness(edgeType, thickness, only);
      break;
    case LINESTYLE:
      mcc_consume_token(LINESTYLE);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        styleName = WordOrText();
        break;
      default:
        mcc_la1[138] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                        noError = impl.SetDumpEdgeTypeLineStyle(edgeType, styleName, only);
      break;
    case LABELS:
      mcc_consume_token(LABELS);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case ON:
        mcc_consume_token(ON);
        break;
      case OFF:
        mcc_consume_token(OFF);
                                         labelStr = "";
        break;
      case DOUBLEQUOTEDTEXT:
      case SINGLEQUOTEDTEXT:
      case WORD:
        labelStr = WordOrText();
        break;
      default:
        mcc_la1[139] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
      LineEnd();
                        noError = impl.SetDumpLabel(edgeType, labelStr, only);
      break;
    default:
      mcc_la1[140] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public void DumpAdd() {
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NODE:
      mcc_consume_token(NODE);
      DumpAddNode();
      break;
    case EDGE:
      mcc_consume_token(EDGE);
      DumpAddEdge();
      break;
    default:
      mcc_la1[141] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public void DumpAddNode() {
        NodeType nodeType, adjNodeType = impl.CurrentGraph.Model.NodeModel.RootType;
        EdgeType edgeType = impl.CurrentGraph.Model.EdgeModel.RootType;
        String attrName, groupModeStr = "incoming";
        bool only = false, onlyEdge = false, onlyAdjNode = false, hidden = false;
        GroupMode groupMode;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case ONLY:
      mcc_consume_token(ONLY);
                  only=true;
      break;
    default:
      mcc_la1[142] = mcc_gen;
      ;
      break;
    }
    nodeType = NodeType();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case EXCLUDE:
      mcc_consume_token(EXCLUDE);
      LineEnd();
                        noError = impl.AddDumpExcludeNodeType(nodeType, only);
      break;
    case GROUP:
      mcc_consume_token(GROUP);
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case BY:
        mcc_consume_token(BY);
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case HIDDEN:
          mcc_consume_token(HIDDEN);
                                     hidden = true;
          break;
        default:
          mcc_la1[143] = mcc_gen;
          ;
          break;
        }
        groupModeStr = WordOrText();
        switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
        case ONLY:
        case DOUBLEQUOTEDTEXT:
        case SINGLEQUOTEDTEXT:
        case WORD:
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case ONLY:
            mcc_consume_token(ONLY);
                              onlyEdge=true;
            break;
          default:
            mcc_la1[144] = mcc_gen;
            ;
            break;
          }
          edgeType = EdgeType();
          switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
          case WITH:
            mcc_consume_token(WITH);
            switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
            case ONLY:
              mcc_consume_token(ONLY);
                                         onlyAdjNode=true;
              break;
            default:
              mcc_la1[145] = mcc_gen;
              ;
              break;
            }
            adjNodeType = NodeType();
            break;
          default:
            mcc_la1[146] = mcc_gen;
            ;
            break;
          }
          break;
        default:
          mcc_la1[147] = mcc_gen;
          ;
          break;
        }
        break;
      default:
        mcc_la1[148] = mcc_gen;
        ;
        break;
      }
      LineEnd();
                switch(groupModeStr)
                {
                    case "no":       groupMode = GroupMode.None;               break;
                    case "incoming": groupMode = GroupMode.GroupIncomingNodes; break;
                    case "outgoing": groupMode = GroupMode.GroupOutgoingNodes; break;
                    case "any":      groupMode = GroupMode.GroupAllNodes;      break;
                    default:
                        Console.WriteLine("Group mode must be one of: no, incoming, outgoing, any");
                        noError = false;
                        {return;}
                }
                if(hidden)
                {
                    if(groupMode == GroupMode.None)
                    {
                        Console.WriteLine("The 'hidden' modifier can not be used with the group mode 'no'!");
                        noError = false;
                        {return;}
                    }
                    groupMode |= GroupMode.Hidden;
                }
            noError = impl.AddDumpGroupNodesBy(nodeType, only, edgeType, onlyEdge, adjNodeType, onlyAdjNode, groupMode);
      break;
    case INFOTAG:
      mcc_consume_token(INFOTAG);
      attrName = WordOrText();
      LineEnd();
                    noError = impl.AddDumpInfoTag(nodeType, attrName, only, false);
      break;
    case SHORTINFOTAG:
      mcc_consume_token(SHORTINFOTAG);
      attrName = WordOrText();
      LineEnd();
                    noError = impl.AddDumpInfoTag(nodeType, attrName, only, true);
      break;
    default:
      mcc_la1[149] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public void DumpAddEdge() {
        EdgeType edgeType = impl.CurrentGraph.Model.EdgeModel.RootType;
        String attrName;
        bool only = false;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case ONLY:
      mcc_consume_token(ONLY);
                  only=true;
      break;
    default:
      mcc_la1[150] = mcc_gen;
      ;
      break;
    }
    edgeType = EdgeType();
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case EXCLUDE:
      mcc_consume_token(EXCLUDE);
      LineEnd();
                noError = impl.AddDumpExcludeEdgeType(edgeType, only);
      break;
    case INFOTAG:
      mcc_consume_token(INFOTAG);
      attrName = WordOrText();
      LineEnd();
            noError = impl.AddDumpInfoTag(edgeType, attrName, only, false);
      break;
    case SHORTINFOTAG:
      mcc_consume_token(SHORTINFOTAG);
      attrName = WordOrText();
      LineEnd();
            noError = impl.AddDumpInfoTag(edgeType, attrName, only, true);
      break;
    default:
      mcc_la1[151] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

///////////////////////
// "custom" commands //
///////////////////////
  public void CustomCommand() {
    List<String> parameters;
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case GRAPH:
      mcc_consume_token(GRAPH);
      parameters = SpacedParametersAndLineEnd();
                impl.CustomGraph(parameters);
      break;
    case ACTIONS:
      mcc_consume_token(ACTIONS);
      parameters = SpacedParametersAndLineEnd();
                impl.CustomActions(parameters);
      break;
    default:
      mcc_la1[152] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
  }

  public List<String> SpacedParametersAndLineEnd() {
    Token tok;
    List<String> parameters = new List<String>();
     token_source.SwitchTo(WithinAnyStrings);
    while (true) {
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case DOUBLEQUOTEDANYSTRINGS:
      case SINGLEQUOTEDANYSTRINGS:
      case ANYSTRINGS:
        ;
        break;
      default:
        mcc_la1[153] = mcc_gen;
        goto label_9;
      }
      switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
      case ANYSTRINGS:
        tok = mcc_consume_token(ANYSTRINGS);
        break;
      case DOUBLEQUOTEDANYSTRINGS:
        tok = mcc_consume_token(DOUBLEQUOTEDANYSTRINGS);
        break;
      case SINGLEQUOTEDANYSTRINGS:
        tok = mcc_consume_token(SINGLEQUOTEDANYSTRINGS);
        break;
      default:
        mcc_la1[154] = mcc_gen;
        mcc_consume_token(-1);
        throw new ParseException();
      }
          parameters.Add(tok.image);
    }label_9: ;
    
    switch ((mcc_ntk==-1)?mcc_mntk():mcc_ntk) {
    case NLINANYSTRINGS:
      mcc_consume_token(NLINANYSTRINGS);
      break;
    case 0:
      mcc_consume_token(0);
      break;
    default:
      mcc_la1[155] = mcc_gen;
      mcc_consume_token(-1);
      throw new ParseException();
    }
        {return parameters;}
    throw new Exception("Missing return statement in function");
  }

  void errorSkip(ParseException ex)  {
        Console.WriteLine(ex.Message);
        Token t;
        do
        {
                t = GetNextToken();
        }
        while(t.kind != EOF && t.kind != NL && t.kind != NLINFILENAME);
  }

  void errorSkipSilent()  {
        Token t;
        do
        {
                t = GetNextToken();
        }
        while(t.kind != EOF && t.kind != NL && t.kind != NLINFILENAME);
  }

  private bool mcc_2_1(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_1(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(0, xla); }
  }

  private bool mcc_2_2(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_2(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(1, xla); }
  }

  private bool mcc_2_3(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_3(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(2, xla); }
  }

  private bool mcc_2_4(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_4(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(3, xla); }
  }

  private bool mcc_2_5(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_5(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(4, xla); }
  }

  private bool mcc_2_6(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_6(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(5, xla); }
  }

  private bool mcc_2_7(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_7(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(6, xla); }
  }

  private bool mcc_2_8(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_8(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(7, xla); }
  }

  private bool mcc_2_9(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_9(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(8, xla); }
  }

  private bool mcc_2_10(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_10(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(9, xla); }
  }

  private bool mcc_2_11(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_11(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(10, xla); }
  }

  private bool mcc_2_12(int xla) {
    mcc_la = xla; mcc_lastpos = mcc_scanpos = token;
    try { return !mcc_3_12(); }
    catch(LookaheadSuccess) { return true; }
    finally { mcc_save(11, xla); }
  }

  private bool mcc_3_8() {
    if (mcc_3R_17()) return true;
    if (mcc_scan_token(MINUS)) return true;
    if (mcc_3R_18()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_19()) {
    mcc_scanpos = xsp;
    if (mcc_3R_20()) return true;
    }
    return false;
  }

  private bool mcc_3_11() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(LAYOUT)) return true;
    return false;
  }

  private bool mcc_3_1() {
    if (mcc_3R_10()) return true;
    if (mcc_scan_token(DOUBLECOLON)) return true;
    return false;
  }

  private bool mcc_3R_15() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_25()) {
    mcc_scanpos = xsp;
    if (mcc_3R_26()) return true;
    }
    return false;
  }

  private bool mcc_3_10() {
    if (mcc_scan_token(NUM)) return true;
    if (mcc_scan_token(NODES)) return true;
    return false;
  }

  private bool mcc_3_3() {
    if (mcc_scan_token(DOT)) return true;
    if (mcc_scan_token(ADD)) return true;
    return false;
  }

  private bool mcc_3_7() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(KEEPDEBUG)) return true;
    return false;
  }

  private bool mcc_3R_20() {
    if (mcc_scan_token(MINUS)) return true;
    return false;
  }

  private bool mcc_3R_16() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(148)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(149)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(150)) {
    mcc_scanpos = xsp;
    if (mcc_3R_27()) return true;
    }
    }
    }
    return false;
  }

  private bool mcc_3_5() {
    if (mcc_3R_15()) return true;
    if (mcc_scan_token(DOT)) return true;
    return false;
  }

  private bool mcc_3R_29() {
    if (mcc_3R_16()) return true;
    return false;
  }

  private bool mcc_3R_28() {
    if (mcc_scan_token(AT)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_10()) return true;
    return false;
  }

  private bool mcc_3R_24() {
    if (mcc_scan_token(0)) return true;
    return false;
  }

  private bool mcc_3R_17() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_28()) {
    mcc_scanpos = xsp;
    if (mcc_3R_29()) return true;
    }
    return false;
  }

  private bool mcc_3R_13() {
    if (mcc_scan_token(DOT)) return true;
    return false;
  }

  private bool mcc_3R_11() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(148)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(149)) return true;
    }
    return false;
  }

  private bool mcc_3R_19() {
    if (mcc_scan_token(ARROW)) return true;
    return false;
  }

  private bool mcc_3_4() {
    if (mcc_3R_12()) return true;
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_13()) mcc_scanpos = xsp;
    if (mcc_3R_14()) return true;
    return false;
  }

  private bool mcc_3_2() {
    if (mcc_3R_11()) return true;
    return false;
  }

  private bool mcc_3R_27() {
    if (mcc_scan_token(DOUBLECOLON)) return true;
    if (mcc_scan_token(WORD)) return true;
    return false;
  }

  private bool mcc_3R_10() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(148)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(149)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(150)) return true;
    }
    }
    return false;
  }

  private bool mcc_3R_23() {
    if (mcc_scan_token(DOUBLECOLON)) return true;
    if (mcc_scan_token(WORD)) return true;
    return false;
  }

  private bool mcc_3R_22() {
    if (mcc_scan_token(WORD)) return true;
    return false;
  }

  private bool mcc_3R_31() {
    if (mcc_scan_token(COLON)) return true;
    return false;
  }

  private bool mcc_3R_21() {
    if (mcc_scan_token(AT)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3R_14() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_scan_token(7)) {
    mcc_scanpos = xsp;
    if (mcc_scan_token(12)) {
    mcc_scanpos = xsp;
    if (mcc_3R_24()) return true;
    }
    }
    return false;
  }

  private bool mcc_3R_30() {
    if (mcc_3R_16()) return true;
    return false;
  }

  private bool mcc_3R_12() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_21()) {
    mcc_scanpos = xsp;
    if (mcc_3R_22()) {
    mcc_scanpos = xsp;
    if (mcc_3R_23()) return true;
    }
    }
    return false;
  }

  private bool mcc_3R_18() {
    Token xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_30()) mcc_scanpos = xsp;
    xsp = mcc_scanpos;
    if (mcc_3R_31()) mcc_scanpos = xsp;
    return false;
  }

  private bool mcc_3_12() {
    if (mcc_scan_token(SET)) return true;
    if (mcc_scan_token(NODE)) return true;
    return false;
  }

  private bool mcc_3R_26() {
    if (mcc_3R_16()) return true;
    return false;
  }

  private bool mcc_3_9() {
    if (mcc_3R_17()) return true;
    if (mcc_scan_token(183)) return true;
    return false;
  }

  private bool mcc_3R_25() {
    if (mcc_scan_token(AT)) return true;
    if (mcc_scan_token(LPARENTHESIS)) return true;
    if (mcc_3R_10()) return true;
    if (mcc_scan_token(RPARENTHESIS)) return true;
    return false;
  }

  private bool mcc_3_6() {
    if (mcc_3R_16()) return true;
    if (mcc_scan_token(EQUAL)) return true;
    return false;
  }

  public GrShellTokenManager token_source;
  SimpleCharStream mcc_input_stream;
  public Token token, mcc_nt;
  private int mcc_ntk;
  private Token mcc_scanpos, mcc_lastpos;
  private int mcc_la;
  public bool lookingAhead = false;
  private bool mcc_semLA;
  private int mcc_gen;
  private int[] mcc_la1 = new int[156];
  static private int[] mcc_la1_0;
  static private int[] mcc_la1_1;
  static private int[] mcc_la1_2;
  static private int[] mcc_la1_3;
  static private int[] mcc_la1_4;
  static private int[] mcc_la1_5;
  static GrShell() {
      mcc_gla1_0();
      mcc_gla1_1();
      mcc_gla1_2();
      mcc_gla1_3();
      mcc_gla1_4();
      mcc_gla1_5();
   }
   private static void mcc_gla1_0() {
      mcc_la1_0 = new int[] {0,0,0,0,0,1024,0,0,0,1024,0,1024,0,0,1,1,0,1,1,1024,1024,1024,1024,1024,1024,0,0,0,0,0,65536,0,65536,0,65536,0,4225,134222977,0,0,0,0,0,0,0,0,0,0,0,0,0,4225,0,-2147418112,-2147483648,20609,32768,0,32768,0,0,1024,134218752,0,0,0,25165824,0,0,7297,1024,65536,131072,131072,1073741824,2048,65536,0,65536,0,65536,0,65536,0,2048,0,65536,0,0,25165824,16778240,1024,0,0,0,0,0,0,0,0,0,0,1024,0,0,1024,0,0,1024,0,0,4225,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,};
   }
   private static void mcc_gla1_1() {
      mcc_la1_1 = new int[] {0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,64,64,64,64,64,64,0,0,0,0,0,0,0,0,0,0,1024,0,-2021980096,0,0,0,0,0,0,0,0,0,0,-2147483648,0,0,-2147483648,-2147483648,0,0,4,0,1024,0,2048,1024,0,-2021980096,0,0,0,0,256,0,0,0,0,0,0,0,0,0,64,0,64,0,64,0,1088,0,8320,0,0,67108864,0,64,268435520,0,0,0,0,0,0,0,0,0,134217728,67117248,0,0,4160,0,0,4160,-2147483648,0,0,-1602224128,0,0,0,0,0,0,278528,0,0,0,0,262144,256,67108864,0,0,0,0,0,0,278528,0,0,0,0,0,0,262144,67108864,0,0,0,0,0,0,32768,1073741824,0,1073741824,128,0,0,0,};
   }
   private static void mcc_gla1_2() {
      mcc_la1_2 = new int[] {0,0,0,0,0,0,268435464,268435464,0,0,8,8,0,0,0,0,0,0,0,0,0,0,268435456,0,0,0,0,0,268435464,268435464,0,268435464,0,268435464,0,276824072,0,104885253,0,16,1,0,0,0,32,0,-1073741824,2,0,0,0,0,0,0,268435464,0,0,8388608,0,0,276824072,0,104885253,0,-1073741824,-1073741824,0,128,0,0,0,0,0,0,0,0,0,268435464,0,268435464,0,268435464,0,276824072,0,128,0,0,67108992,0,0,0,0,0,0,0,0,0,0,0,0,134217728,603980160,0,0,0,0,0,0,0,0,0,1049600,64,0,0,0,0,0,0,0,0,0,0,0,128,67108864,0,0,0,0,0,-1073741824,524288,0,0,0,0,0,-1073741824,524288,67108864,0,4096,0,0,0,0,0,33280,0,32768,128,0,0,0,};
   }
   private static void mcc_gla1_3() {
      mcc_la1_3 = new int[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,262144,0,1080272848,0,0,128,0,83886080,83886080,0,0,0,0,0,1,33554432,33554432,0,0,0,0,0,262144,0,0,262144,0,1080272848,0,0,0,0,0,262144,0,0,0,0,0,0,0,0,0,0,0,0,0,0,262144,0,32,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,805306368,1,1,805306368,0,0,4,0,0,262144,0,0,0,0,-2146959360,0,0,0,0,-2013265920,278528,0,1,0,0,0,0,0,-2146959360,1,0,0,0,0,0,-2013265920,0,1,0,1,1,0,1,0,1048576,1,1048576,0,0,0,0,};
   }
   private static void mcc_gla1_4() {
      mcc_la1_4 = new int[] {0,0,7340032,3145728,7348736,7340032,7863812,7863812,8704,7340544,4,7340036,939524096,939524096,1073741824,2013265920,939524096,1073741824,2013265920,7340032,7340032,4194304,7340032,7340032,7340032,7348736,130560,523776,7340036,7863812,0,7863812,0,7863812,0,7863812,0,7340320,7348736,7340032,0,7348736,0,0,0,2,0,0,256,0,0,256,256,0,7863812,0,0,7340032,0,0,7863812,7340032,7340320,7340032,0,0,0,0,0,7340032,7340032,0,7340032,7340032,0,0,0,7863812,0,7863812,0,7863812,0,7863812,0,0,0,7348736,0,0,7340032,7340032,0,7340032,0,7340032,0,7340032,0,7340032,7340032,0,7340096,0,7340032,7340048,0,7340032,7340048,256,7340032,7340032,256,0,0,7340032,7340032,7340032,7340032,0,7340032,7340032,8704,7340032,1,0,0,0,7340032,7340032,7340032,7340032,7340032,0,0,7340032,7340032,8704,7340032,7340032,1,0,0,0,0,0,128,7340032,0,0,0,0,0,0,0,0,};
   }
   private static void mcc_gla1_5() {
      mcc_la1_5 = new int[] {112,1792,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1835008,1835008,2097152,};
   }
  private MccCalls[] mcc_2_rtns = new MccCalls[12];
  private bool mcc_rescan = false;
  private int mcc_gc = 0;

  public GrShell(System.IO.Stream stream) {
    mcc_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new GrShellTokenManager(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 156; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public void ReInit(System.IO.Stream stream) {
    mcc_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 156; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public GrShell(System.IO.TextReader stream) {
    mcc_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new GrShellTokenManager(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 156; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public void ReInit(System.IO.TextReader stream) {
    mcc_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(mcc_input_stream);
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 156; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public GrShell(GrShellTokenManager tm) {
    token_source = tm;
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 156; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

  public void ReInit(GrShellTokenManager tm) {
    token_source = tm;
    token = new Token();
    mcc_ntk = -1;
    mcc_gen = 0;
    for (int i = 0; i < 156; i++) mcc_la1[i] = -1;
    for (int i = 0; i < mcc_2_rtns.Length; i++) mcc_2_rtns[i] = new MccCalls();
  }

   private Token mcc_consume_token(int kind) {
    Token oldToken = null;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.GetNextToken();
    mcc_ntk = -1;
    if (token.kind == kind) {
      mcc_gen++;
      if (++mcc_gc > 100) {
        mcc_gc = 0;
        for (int i = 0; i < mcc_2_rtns.Length; i++) {
          MccCalls c = mcc_2_rtns[i];
          while (c != null) {
            if (c.gen < mcc_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    mcc_kind = kind;
    throw GenerateParseException();
  }

  private class LookaheadSuccess : System.Exception { }
  private LookaheadSuccess mcc_ls = new LookaheadSuccess();
  private bool mcc_scan_token(int kind) {
    if (mcc_scanpos == mcc_lastpos) {
      mcc_la--;
      if (mcc_scanpos.next == null) {
        mcc_lastpos = mcc_scanpos = mcc_scanpos.next = token_source.GetNextToken();
      } else {
        mcc_lastpos = mcc_scanpos = mcc_scanpos.next;
      }
    } else {
      mcc_scanpos = mcc_scanpos.next;
    }
    if (mcc_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != mcc_scanpos) { i++; tok = tok.next; }
      if (tok != null) mcc_add_error_token(kind, i);
    }
    if (mcc_scanpos.kind != kind) return true;
    if (mcc_la == 0 && mcc_scanpos == mcc_lastpos) throw mcc_ls;
    return false;
  }

  public Token GetNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.GetNextToken();
    mcc_ntk = -1;
    mcc_gen++;
    return token;
  }

  public Token GetToken(int index) {
    Token t = lookingAhead ? mcc_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.GetNextToken();
    }
    return t;
  }

  private int mcc_mntk() {
    if ((mcc_nt=token.next) == null)
      return (mcc_ntk = (token.next=token_source.GetNextToken()).kind);
    else
      return (mcc_ntk = mcc_nt.kind);
  }

  private System.Collections.ArrayList mcc_expentries = new System.Collections.ArrayList();
  private int[] mcc_expentry;
  private int mcc_kind = -1;
  private int[] mcc_lasttokens = new int[100];
  private int mcc_endpos;

  private void mcc_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == mcc_endpos + 1) {
      mcc_lasttokens[mcc_endpos++] = kind;
    } else if (mcc_endpos != 0) {
      mcc_expentry = new int[mcc_endpos];
      for (int i = 0; i < mcc_endpos; i++) {
        mcc_expentry[i] = mcc_lasttokens[i];
      }
      bool exists = false;
      for (System.Collections.IEnumerator e = mcc_expentries.GetEnumerator(); e.MoveNext();) {
        int[] oldentry = (int[])e.Current;
        if (oldentry.Length == mcc_expentry.Length) {
          exists = true;
          for (int i = 0; i < mcc_expentry.Length; i++) {
            if (oldentry[i] != mcc_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) mcc_expentries.Add(mcc_expentry);
      if (pos != 0) mcc_lasttokens[(mcc_endpos = pos) - 1] = kind;
    }
  }

  public ParseException GenerateParseException() {
    mcc_expentries.Clear();
    bool[] la1tokens = new bool[185];
    for (int i = 0; i < 185; i++) {
      la1tokens[i] = false;
    }
    if (mcc_kind >= 0) {
      la1tokens[mcc_kind] = true;
      mcc_kind = -1;
    }
    for (int i = 0; i < 156; i++) {
      if (mcc_la1[i] == mcc_gen) {
        for (int j = 0; j < 32; j++) {
          if ((mcc_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((mcc_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((mcc_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((mcc_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((mcc_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((mcc_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 185; i++) {
      if (la1tokens[i]) {
        mcc_expentry = new int[1];
        mcc_expentry[0] = i;
        mcc_expentries.Add(mcc_expentry);
      }
    }
    mcc_endpos = 0;
    mcc_rescan_token();
    mcc_add_error_token(0, 0);
    int[][] exptokseq = new int[mcc_expentries.Count][];
    for (int i = 0; i < mcc_expentries.Count; i++) {
      exptokseq[i] = (int[])mcc_expentries[i];
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  public void enable_tracing() {
  }

  public void disable_tracing() {
  }

  private void mcc_rescan_token() {
    mcc_rescan = true;
    for (int i = 0; i < 12; i++) {
      MccCalls p = mcc_2_rtns[i];
      do {
        if (p.gen > mcc_gen) {
          mcc_la = p.arg; mcc_lastpos = mcc_scanpos = p.first;
          switch (i) {
            case 0: mcc_3_1(); break;
            case 1: mcc_3_2(); break;
            case 2: mcc_3_3(); break;
            case 3: mcc_3_4(); break;
            case 4: mcc_3_5(); break;
            case 5: mcc_3_6(); break;
            case 6: mcc_3_7(); break;
            case 7: mcc_3_8(); break;
            case 8: mcc_3_9(); break;
            case 9: mcc_3_10(); break;
            case 10: mcc_3_11(); break;
            case 11: mcc_3_12(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    mcc_rescan = false;
  }

  private void mcc_save(int index, int xla) {
    MccCalls p = mcc_2_rtns[index];
    while (p.gen > mcc_gen) {
      if (p.next == null) { p = p.next = new MccCalls(); break; }
      p = p.next;
    }
    p.gen = mcc_gen + xla - mcc_la; p.first = token; p.arg = xla;
  }

  class MccCalls {
    public int gen;
    public Token first;
    public int arg;
    public MccCalls next;
  }

    }
}
